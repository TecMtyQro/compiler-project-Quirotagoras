Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    ARRAY
    COMA
    COMMENT_LINE
    DEF
    DOT
    DOUBLEAPOSTROPHE
    FLOAT_NUMBER
    LBRACKET
    LCORCHETE
    LIST
    RBRACKET
    RCORCHETE
    RETURN

Grammar

Rule 0     S' -> file_input
Rule 1     file_input -> stmt file_inputhelp
Rule 2     file_inputhelp -> file_input
Rule 3     file_inputhelp -> empty
Rule 4     stmt -> simple_stmt
Rule 5     stmt -> compound_stmt
Rule 6     simple_stmt -> small_stmt simplehelper
Rule 7     simplehelper -> NEWLINE small_stmt simplehelper
Rule 8     simplehelper -> empty
Rule 9     small_stmt -> expr_stmt
Rule 10    small_stmt -> print_stmt
Rule 11    small_stmt -> input_stmt
Rule 12    print_stmt -> PRINT LPAREN test RPAREN
Rule 13    input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN
Rule 14    expr_stmt -> typotest
Rule 15    expr_stmt -> augassign
Rule 16    expr_stmt -> annassign
Rule 17    typotest -> CDEF vartypes
Rule 18    vartypes -> INT test ASSIGN test
Rule 19    vartypes -> DOUBLE test ASSIGN test
Rule 20    vartypes -> SHORT test ASSIGN test
Rule 21    vartypes -> LONG test ASSIGN test
Rule 22    vartypes -> CHAR test ASSIGN test
Rule 23    vartypes -> FLOAT test ASSIGN test
Rule 24    annassign -> test ASSIGN test
Rule 25    augassign -> test PLUS_ASSIGN test
Rule 26    augassign -> test MINUS_ASSIGN test
Rule 27    augassign -> test TIMES_ASSIGN test
Rule 28    augassign -> test DIVIDE_ASSIGN test
Rule 29    augassign -> test ASSIGN_MODULE test
Rule 30    compound_stmt -> if_stmnt
Rule 31    compound_stmt -> for_stmt
Rule 32    compound_stmt -> break_stmt
Rule 33    break_stmt -> BREAK
Rule 34    if_stmnt -> IF test THEN suite NEWLINE
Rule 35    if_stmnt -> compound_if
Rule 36    compound_if -> IF test THEN itersuite elif_stmnt else_stmnt
Rule 37    compound_if -> IF test THEN itersuite if_stmnt else_stmnt
Rule 38    itersuite -> suite itersuite
Rule 39    itersuite -> suite elif_stmnt
Rule 40    else_stmnt -> ELSE THEN suite
Rule 41    else_stmnt -> ELSE THEN if_stmnt
Rule 42    else_stmnt -> empty
Rule 43    elif_stmnt -> ELIF test THEN suite elif_stmnt
Rule 44    elif_stmnt -> else_stmnt
Rule 45    for_stmt -> FOR exprlist IN testlist THEN stmt
Rule 46    for_stmt -> FOR exprlist IN RANGE THEN stmt
Rule 47    exprlist -> expression exprlisthelper
Rule 48    exprlisthelper -> NEWLINE expression exprlisthelper
Rule 49    exprlisthelper -> empty
Rule 50    testlist -> test testlisthelper
Rule 51    testlisthelper -> NEWLINE test exprlisthelper
Rule 52    testlisthelper -> empty
Rule 53    suite -> simple_stmt
Rule 54    suite -> NEWLINE INDENT stmt
Rule 55    test -> or_test
Rule 56    or_test -> and_test or_comp
Rule 57    or_comp -> OR and_test or_comp
Rule 58    or_comp -> empty
Rule 59    and_test -> not_test and_comp
Rule 60    and_comp -> AND not_test and_comp
Rule 61    and_comp -> empty
Rule 62    not_test -> NOT not_test
Rule 63    not_test -> comparison
Rule 64    comparison -> expression comphelper
Rule 65    comphelper -> comp_op expression comphelper
Rule 66    comphelper -> empty
Rule 67    comp_op -> LESS_THAN
Rule 68    comp_op -> MORE_THAN
Rule 69    comp_op -> EQUALS
Rule 70    comp_op -> MORE_EQUAL
Rule 71    comp_op -> LESS_EQUAL
Rule 72    comp_op -> NOT_EQUAL
Rule 73    comp_op -> IN
Rule 74    comp_op -> NOT_IN
Rule 75    comp_op -> IS
Rule 76    comp_op -> IS_NOT
Rule 77    expression -> arith_expr
Rule 78    arith_expr -> term PLUS arith_expr
Rule 79    arith_expr -> term MINUS arith_expr
Rule 80    arith_expr -> term empty
Rule 81    term -> factor TIMES term
Rule 82    term -> factor DIVIDE term
Rule 83    term -> factor MODULE term
Rule 84    term -> factor empty
Rule 85    factor -> LPAREN MINUS factor RPAREN
Rule 86    factor -> power
Rule 87    power -> factor POWER factor
Rule 88    power -> atom_expr empty
Rule 89    atom_expr -> atom
Rule 90    atom -> ID
Rule 91    atom -> NUMBER
Rule 92    atom -> STRING
Rule 93    atom -> BOOL_TRUE
Rule 94    atom -> BOOL_FALSE
Rule 95    atom -> NONE
Rule 96    empty -> <empty>

Terminals, with rules where they appear

AND                  : 60
APOSTROPHE           : 
ARRAY                : 
ASSIGN               : 13 18 19 20 21 22 23 24
ASSIGN_MODULE        : 29
BOOL_FALSE           : 94
BOOL_TRUE            : 93
BREAK                : 33
CDEF                 : 17
CHAR                 : 22
COMA                 : 
COMMENT_LINE         : 
DEF                  : 
DIVIDE               : 82
DIVIDE_ASSIGN        : 28
DOT                  : 
DOUBLE               : 19
DOUBLEAPOSTROPHE     : 
ELIF                 : 43
ELSE                 : 40 41
EQUALS               : 69
FLOAT                : 23
FLOAT_NUMBER         : 
FOR                  : 45 46
ID                   : 90
IF                   : 34 36 37
IN                   : 45 46 73
INDENT               : 54
INPUT                : 13
INT                  : 18
IS                   : 75
IS_NOT               : 76
LBRACKET             : 
LCORCHETE            : 
LESS_EQUAL           : 71
LESS_THAN            : 67
LIST                 : 
LONG                 : 21
LPAREN               : 12 13 85
MINUS                : 79 85
MINUS_ASSIGN         : 26
MODULE               : 83
MORE_EQUAL           : 70
MORE_THAN            : 68
NEWLINE              : 7 34 48 51 54
NONE                 : 95
NOT                  : 62
NOT_EQUAL            : 72
NOT_IN               : 74
NUMBER               : 91
OR                   : 57
PLUS                 : 78
PLUS_ASSIGN          : 25
POWER                : 87
PRINT                : 12
RANGE                : 46
RBRACKET             : 
RCORCHETE            : 
RETURN               : 
RPAREN               : 12 13 85
SHORT                : 20
STRING               : 13 92
THEN                 : 34 36 37 40 41 43 45 46
TIMES                : 81
TIMES_ASSIGN         : 27
error                : 

Nonterminals, with rules where they appear

and_comp             : 59 60
and_test             : 56 57
annassign            : 16
arith_expr           : 77 78 79
atom                 : 89
atom_expr            : 88
augassign            : 15
break_stmt           : 32
comp_op              : 65
comparison           : 63
comphelper           : 64 65
compound_if          : 35
compound_stmt        : 5
elif_stmnt           : 36 39 43
else_stmnt           : 36 37 44
empty                : 3 8 42 49 52 58 61 66 80 84 88
expr_stmt            : 9
expression           : 47 48 64 65
exprlist             : 45 46
exprlisthelper       : 47 48 51
factor               : 81 82 83 84 85 87 87
file_input           : 2 0
file_inputhelp       : 1
for_stmt             : 31
if_stmnt             : 30 37 41
input_stmt           : 11
itersuite            : 36 37 38
not_test             : 59 60 62
or_comp              : 56 57
or_test              : 55
power                : 86
print_stmt           : 10
simple_stmt          : 4 53
simplehelper         : 6 7
small_stmt           : 6 7
stmt                 : 1 45 46 54
suite                : 34 38 39 40 43
term                 : 78 79 80 81 82 83
test                 : 12 13 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 34 36 37 43 50 51
testlist             : 45
testlisthelper       : 50
typotest             : 14
vartypes             : 17

Parsing method: LALR

state 0

    (0) S' -> . file_input
    (1) file_input -> . stmt file_inputhelp
    (4) stmt -> . simple_stmt
    (5) stmt -> . compound_stmt
    (6) simple_stmt -> . small_stmt simplehelper
    (30) compound_stmt -> . if_stmnt
    (31) compound_stmt -> . for_stmt
    (32) compound_stmt -> . break_stmt
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (45) for_stmt -> . FOR exprlist IN testlist THEN stmt
    (46) for_stmt -> . FOR exprlist IN RANGE THEN stmt
    (33) break_stmt -> . BREAK
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    IF              shift and go to state 12
    FOR             shift and go to state 15
    BREAK           shift and go to state 16
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    file_input                     shift and go to state 1
    stmt                           shift and go to state 2
    simple_stmt                    shift and go to state 3
    compound_stmt                  shift and go to state 4
    small_stmt                     shift and go to state 5
    if_stmnt                       shift and go to state 6
    for_stmt                       shift and go to state 7
    break_stmt                     shift and go to state 8
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    test                           shift and go to state 13
    compound_if                    shift and go to state 14
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 1

    (0) S' -> file_input .



state 2

    (1) file_input -> stmt . file_inputhelp
    (2) file_inputhelp -> . file_input
    (3) file_inputhelp -> . empty
    (1) file_input -> . stmt file_inputhelp
    (96) empty -> .
    (4) stmt -> . simple_stmt
    (5) stmt -> . compound_stmt
    (6) simple_stmt -> . small_stmt simplehelper
    (30) compound_stmt -> . if_stmnt
    (31) compound_stmt -> . for_stmt
    (32) compound_stmt -> . break_stmt
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (45) for_stmt -> . FOR exprlist IN testlist THEN stmt
    (46) for_stmt -> . FOR exprlist IN RANGE THEN stmt
    (33) break_stmt -> . BREAK
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    $end            reduce using rule 96 (empty -> .)
    IF              shift and go to state 12
    FOR             shift and go to state 15
    BREAK           shift and go to state 16
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    stmt                           shift and go to state 2
    file_inputhelp                 shift and go to state 41
    file_input                     shift and go to state 42
    empty                          shift and go to state 43
    simple_stmt                    shift and go to state 3
    compound_stmt                  shift and go to state 4
    small_stmt                     shift and go to state 5
    if_stmnt                       shift and go to state 6
    for_stmt                       shift and go to state 7
    break_stmt                     shift and go to state 8
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    test                           shift and go to state 13
    compound_if                    shift and go to state 14
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 3

    (4) stmt -> simple_stmt .

    IF              reduce using rule 4 (stmt -> simple_stmt .)
    FOR             reduce using rule 4 (stmt -> simple_stmt .)
    BREAK           reduce using rule 4 (stmt -> simple_stmt .)
    PRINT           reduce using rule 4 (stmt -> simple_stmt .)
    CDEF            reduce using rule 4 (stmt -> simple_stmt .)
    NOT             reduce using rule 4 (stmt -> simple_stmt .)
    LPAREN          reduce using rule 4 (stmt -> simple_stmt .)
    ID              reduce using rule 4 (stmt -> simple_stmt .)
    NUMBER          reduce using rule 4 (stmt -> simple_stmt .)
    STRING          reduce using rule 4 (stmt -> simple_stmt .)
    BOOL_TRUE       reduce using rule 4 (stmt -> simple_stmt .)
    BOOL_FALSE      reduce using rule 4 (stmt -> simple_stmt .)
    NONE            reduce using rule 4 (stmt -> simple_stmt .)
    $end            reduce using rule 4 (stmt -> simple_stmt .)
    NEWLINE         reduce using rule 4 (stmt -> simple_stmt .)
    ELIF            reduce using rule 4 (stmt -> simple_stmt .)
    ELSE            reduce using rule 4 (stmt -> simple_stmt .)


state 4

    (5) stmt -> compound_stmt .

    IF              reduce using rule 5 (stmt -> compound_stmt .)
    FOR             reduce using rule 5 (stmt -> compound_stmt .)
    BREAK           reduce using rule 5 (stmt -> compound_stmt .)
    PRINT           reduce using rule 5 (stmt -> compound_stmt .)
    CDEF            reduce using rule 5 (stmt -> compound_stmt .)
    NOT             reduce using rule 5 (stmt -> compound_stmt .)
    LPAREN          reduce using rule 5 (stmt -> compound_stmt .)
    ID              reduce using rule 5 (stmt -> compound_stmt .)
    NUMBER          reduce using rule 5 (stmt -> compound_stmt .)
    STRING          reduce using rule 5 (stmt -> compound_stmt .)
    BOOL_TRUE       reduce using rule 5 (stmt -> compound_stmt .)
    BOOL_FALSE      reduce using rule 5 (stmt -> compound_stmt .)
    NONE            reduce using rule 5 (stmt -> compound_stmt .)
    $end            reduce using rule 5 (stmt -> compound_stmt .)
    NEWLINE         reduce using rule 5 (stmt -> compound_stmt .)
    ELIF            reduce using rule 5 (stmt -> compound_stmt .)
    ELSE            reduce using rule 5 (stmt -> compound_stmt .)


state 5

    (6) simple_stmt -> small_stmt . simplehelper
    (7) simplehelper -> . NEWLINE small_stmt simplehelper
    (8) simplehelper -> . empty
    (96) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 45
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)

  ! NEWLINE         [ reduce using rule 96 (empty -> .) ]

    simplehelper                   shift and go to state 44
    empty                          shift and go to state 46

state 6

    (30) compound_stmt -> if_stmnt .

    IF              reduce using rule 30 (compound_stmt -> if_stmnt .)
    FOR             reduce using rule 30 (compound_stmt -> if_stmnt .)
    BREAK           reduce using rule 30 (compound_stmt -> if_stmnt .)
    PRINT           reduce using rule 30 (compound_stmt -> if_stmnt .)
    CDEF            reduce using rule 30 (compound_stmt -> if_stmnt .)
    NOT             reduce using rule 30 (compound_stmt -> if_stmnt .)
    LPAREN          reduce using rule 30 (compound_stmt -> if_stmnt .)
    ID              reduce using rule 30 (compound_stmt -> if_stmnt .)
    NUMBER          reduce using rule 30 (compound_stmt -> if_stmnt .)
    STRING          reduce using rule 30 (compound_stmt -> if_stmnt .)
    BOOL_TRUE       reduce using rule 30 (compound_stmt -> if_stmnt .)
    BOOL_FALSE      reduce using rule 30 (compound_stmt -> if_stmnt .)
    NONE            reduce using rule 30 (compound_stmt -> if_stmnt .)
    $end            reduce using rule 30 (compound_stmt -> if_stmnt .)
    NEWLINE         reduce using rule 30 (compound_stmt -> if_stmnt .)
    ELIF            reduce using rule 30 (compound_stmt -> if_stmnt .)
    ELSE            reduce using rule 30 (compound_stmt -> if_stmnt .)


state 7

    (31) compound_stmt -> for_stmt .

    IF              reduce using rule 31 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 31 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 31 (compound_stmt -> for_stmt .)
    PRINT           reduce using rule 31 (compound_stmt -> for_stmt .)
    CDEF            reduce using rule 31 (compound_stmt -> for_stmt .)
    NOT             reduce using rule 31 (compound_stmt -> for_stmt .)
    LPAREN          reduce using rule 31 (compound_stmt -> for_stmt .)
    ID              reduce using rule 31 (compound_stmt -> for_stmt .)
    NUMBER          reduce using rule 31 (compound_stmt -> for_stmt .)
    STRING          reduce using rule 31 (compound_stmt -> for_stmt .)
    BOOL_TRUE       reduce using rule 31 (compound_stmt -> for_stmt .)
    BOOL_FALSE      reduce using rule 31 (compound_stmt -> for_stmt .)
    NONE            reduce using rule 31 (compound_stmt -> for_stmt .)
    $end            reduce using rule 31 (compound_stmt -> for_stmt .)
    NEWLINE         reduce using rule 31 (compound_stmt -> for_stmt .)
    ELIF            reduce using rule 31 (compound_stmt -> for_stmt .)
    ELSE            reduce using rule 31 (compound_stmt -> for_stmt .)


state 8

    (32) compound_stmt -> break_stmt .

    IF              reduce using rule 32 (compound_stmt -> break_stmt .)
    FOR             reduce using rule 32 (compound_stmt -> break_stmt .)
    BREAK           reduce using rule 32 (compound_stmt -> break_stmt .)
    PRINT           reduce using rule 32 (compound_stmt -> break_stmt .)
    CDEF            reduce using rule 32 (compound_stmt -> break_stmt .)
    NOT             reduce using rule 32 (compound_stmt -> break_stmt .)
    LPAREN          reduce using rule 32 (compound_stmt -> break_stmt .)
    ID              reduce using rule 32 (compound_stmt -> break_stmt .)
    NUMBER          reduce using rule 32 (compound_stmt -> break_stmt .)
    STRING          reduce using rule 32 (compound_stmt -> break_stmt .)
    BOOL_TRUE       reduce using rule 32 (compound_stmt -> break_stmt .)
    BOOL_FALSE      reduce using rule 32 (compound_stmt -> break_stmt .)
    NONE            reduce using rule 32 (compound_stmt -> break_stmt .)
    $end            reduce using rule 32 (compound_stmt -> break_stmt .)
    NEWLINE         reduce using rule 32 (compound_stmt -> break_stmt .)
    ELIF            reduce using rule 32 (compound_stmt -> break_stmt .)
    ELSE            reduce using rule 32 (compound_stmt -> break_stmt .)


state 9

    (9) small_stmt -> expr_stmt .

    NEWLINE         reduce using rule 9 (small_stmt -> expr_stmt .)
    IF              reduce using rule 9 (small_stmt -> expr_stmt .)
    FOR             reduce using rule 9 (small_stmt -> expr_stmt .)
    BREAK           reduce using rule 9 (small_stmt -> expr_stmt .)
    PRINT           reduce using rule 9 (small_stmt -> expr_stmt .)
    CDEF            reduce using rule 9 (small_stmt -> expr_stmt .)
    NOT             reduce using rule 9 (small_stmt -> expr_stmt .)
    LPAREN          reduce using rule 9 (small_stmt -> expr_stmt .)
    ID              reduce using rule 9 (small_stmt -> expr_stmt .)
    NUMBER          reduce using rule 9 (small_stmt -> expr_stmt .)
    STRING          reduce using rule 9 (small_stmt -> expr_stmt .)
    BOOL_TRUE       reduce using rule 9 (small_stmt -> expr_stmt .)
    BOOL_FALSE      reduce using rule 9 (small_stmt -> expr_stmt .)
    NONE            reduce using rule 9 (small_stmt -> expr_stmt .)
    $end            reduce using rule 9 (small_stmt -> expr_stmt .)
    ELIF            reduce using rule 9 (small_stmt -> expr_stmt .)
    ELSE            reduce using rule 9 (small_stmt -> expr_stmt .)


state 10

    (10) small_stmt -> print_stmt .

    NEWLINE         reduce using rule 10 (small_stmt -> print_stmt .)
    IF              reduce using rule 10 (small_stmt -> print_stmt .)
    FOR             reduce using rule 10 (small_stmt -> print_stmt .)
    BREAK           reduce using rule 10 (small_stmt -> print_stmt .)
    PRINT           reduce using rule 10 (small_stmt -> print_stmt .)
    CDEF            reduce using rule 10 (small_stmt -> print_stmt .)
    NOT             reduce using rule 10 (small_stmt -> print_stmt .)
    LPAREN          reduce using rule 10 (small_stmt -> print_stmt .)
    ID              reduce using rule 10 (small_stmt -> print_stmt .)
    NUMBER          reduce using rule 10 (small_stmt -> print_stmt .)
    STRING          reduce using rule 10 (small_stmt -> print_stmt .)
    BOOL_TRUE       reduce using rule 10 (small_stmt -> print_stmt .)
    BOOL_FALSE      reduce using rule 10 (small_stmt -> print_stmt .)
    NONE            reduce using rule 10 (small_stmt -> print_stmt .)
    $end            reduce using rule 10 (small_stmt -> print_stmt .)
    ELIF            reduce using rule 10 (small_stmt -> print_stmt .)
    ELSE            reduce using rule 10 (small_stmt -> print_stmt .)


state 11

    (11) small_stmt -> input_stmt .

    NEWLINE         reduce using rule 11 (small_stmt -> input_stmt .)
    IF              reduce using rule 11 (small_stmt -> input_stmt .)
    FOR             reduce using rule 11 (small_stmt -> input_stmt .)
    BREAK           reduce using rule 11 (small_stmt -> input_stmt .)
    PRINT           reduce using rule 11 (small_stmt -> input_stmt .)
    CDEF            reduce using rule 11 (small_stmt -> input_stmt .)
    NOT             reduce using rule 11 (small_stmt -> input_stmt .)
    LPAREN          reduce using rule 11 (small_stmt -> input_stmt .)
    ID              reduce using rule 11 (small_stmt -> input_stmt .)
    NUMBER          reduce using rule 11 (small_stmt -> input_stmt .)
    STRING          reduce using rule 11 (small_stmt -> input_stmt .)
    BOOL_TRUE       reduce using rule 11 (small_stmt -> input_stmt .)
    BOOL_FALSE      reduce using rule 11 (small_stmt -> input_stmt .)
    NONE            reduce using rule 11 (small_stmt -> input_stmt .)
    $end            reduce using rule 11 (small_stmt -> input_stmt .)
    ELIF            reduce using rule 11 (small_stmt -> input_stmt .)
    ELSE            reduce using rule 11 (small_stmt -> input_stmt .)


state 12

    (34) if_stmnt -> IF . test THEN suite NEWLINE
    (36) compound_if -> IF . test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> IF . test THEN itersuite if_stmnt else_stmnt
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 47
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 13

    (13) input_stmt -> test . ASSIGN INPUT LPAREN STRING RPAREN
    (25) augassign -> test . PLUS_ASSIGN test
    (26) augassign -> test . MINUS_ASSIGN test
    (27) augassign -> test . TIMES_ASSIGN test
    (28) augassign -> test . DIVIDE_ASSIGN test
    (29) augassign -> test . ASSIGN_MODULE test
    (24) annassign -> test . ASSIGN test

    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    TIMES_ASSIGN    shift and go to state 51
    DIVIDE_ASSIGN   shift and go to state 52
    ASSIGN_MODULE   shift and go to state 53


state 14

    (35) if_stmnt -> compound_if .

    IF              reduce using rule 35 (if_stmnt -> compound_if .)
    FOR             reduce using rule 35 (if_stmnt -> compound_if .)
    BREAK           reduce using rule 35 (if_stmnt -> compound_if .)
    PRINT           reduce using rule 35 (if_stmnt -> compound_if .)
    CDEF            reduce using rule 35 (if_stmnt -> compound_if .)
    NOT             reduce using rule 35 (if_stmnt -> compound_if .)
    LPAREN          reduce using rule 35 (if_stmnt -> compound_if .)
    ID              reduce using rule 35 (if_stmnt -> compound_if .)
    NUMBER          reduce using rule 35 (if_stmnt -> compound_if .)
    STRING          reduce using rule 35 (if_stmnt -> compound_if .)
    BOOL_TRUE       reduce using rule 35 (if_stmnt -> compound_if .)
    BOOL_FALSE      reduce using rule 35 (if_stmnt -> compound_if .)
    NONE            reduce using rule 35 (if_stmnt -> compound_if .)
    $end            reduce using rule 35 (if_stmnt -> compound_if .)
    NEWLINE         reduce using rule 35 (if_stmnt -> compound_if .)
    ELIF            reduce using rule 35 (if_stmnt -> compound_if .)
    ELSE            reduce using rule 35 (if_stmnt -> compound_if .)


state 15

    (45) for_stmt -> FOR . exprlist IN testlist THEN stmt
    (46) for_stmt -> FOR . exprlist IN RANGE THEN stmt
    (47) exprlist -> . expression exprlisthelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    exprlist                       shift and go to state 54
    expression                     shift and go to state 55
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 16

    (33) break_stmt -> BREAK .

    IF              reduce using rule 33 (break_stmt -> BREAK .)
    FOR             reduce using rule 33 (break_stmt -> BREAK .)
    BREAK           reduce using rule 33 (break_stmt -> BREAK .)
    PRINT           reduce using rule 33 (break_stmt -> BREAK .)
    CDEF            reduce using rule 33 (break_stmt -> BREAK .)
    NOT             reduce using rule 33 (break_stmt -> BREAK .)
    LPAREN          reduce using rule 33 (break_stmt -> BREAK .)
    ID              reduce using rule 33 (break_stmt -> BREAK .)
    NUMBER          reduce using rule 33 (break_stmt -> BREAK .)
    STRING          reduce using rule 33 (break_stmt -> BREAK .)
    BOOL_TRUE       reduce using rule 33 (break_stmt -> BREAK .)
    BOOL_FALSE      reduce using rule 33 (break_stmt -> BREAK .)
    NONE            reduce using rule 33 (break_stmt -> BREAK .)
    $end            reduce using rule 33 (break_stmt -> BREAK .)
    NEWLINE         reduce using rule 33 (break_stmt -> BREAK .)
    ELIF            reduce using rule 33 (break_stmt -> BREAK .)
    ELSE            reduce using rule 33 (break_stmt -> BREAK .)


state 17

    (14) expr_stmt -> typotest .

    NEWLINE         reduce using rule 14 (expr_stmt -> typotest .)
    IF              reduce using rule 14 (expr_stmt -> typotest .)
    FOR             reduce using rule 14 (expr_stmt -> typotest .)
    BREAK           reduce using rule 14 (expr_stmt -> typotest .)
    PRINT           reduce using rule 14 (expr_stmt -> typotest .)
    CDEF            reduce using rule 14 (expr_stmt -> typotest .)
    NOT             reduce using rule 14 (expr_stmt -> typotest .)
    LPAREN          reduce using rule 14 (expr_stmt -> typotest .)
    ID              reduce using rule 14 (expr_stmt -> typotest .)
    NUMBER          reduce using rule 14 (expr_stmt -> typotest .)
    STRING          reduce using rule 14 (expr_stmt -> typotest .)
    BOOL_TRUE       reduce using rule 14 (expr_stmt -> typotest .)
    BOOL_FALSE      reduce using rule 14 (expr_stmt -> typotest .)
    NONE            reduce using rule 14 (expr_stmt -> typotest .)
    $end            reduce using rule 14 (expr_stmt -> typotest .)
    ELIF            reduce using rule 14 (expr_stmt -> typotest .)
    ELSE            reduce using rule 14 (expr_stmt -> typotest .)


state 18

    (15) expr_stmt -> augassign .

    NEWLINE         reduce using rule 15 (expr_stmt -> augassign .)
    IF              reduce using rule 15 (expr_stmt -> augassign .)
    FOR             reduce using rule 15 (expr_stmt -> augassign .)
    BREAK           reduce using rule 15 (expr_stmt -> augassign .)
    PRINT           reduce using rule 15 (expr_stmt -> augassign .)
    CDEF            reduce using rule 15 (expr_stmt -> augassign .)
    NOT             reduce using rule 15 (expr_stmt -> augassign .)
    LPAREN          reduce using rule 15 (expr_stmt -> augassign .)
    ID              reduce using rule 15 (expr_stmt -> augassign .)
    NUMBER          reduce using rule 15 (expr_stmt -> augassign .)
    STRING          reduce using rule 15 (expr_stmt -> augassign .)
    BOOL_TRUE       reduce using rule 15 (expr_stmt -> augassign .)
    BOOL_FALSE      reduce using rule 15 (expr_stmt -> augassign .)
    NONE            reduce using rule 15 (expr_stmt -> augassign .)
    $end            reduce using rule 15 (expr_stmt -> augassign .)
    ELIF            reduce using rule 15 (expr_stmt -> augassign .)
    ELSE            reduce using rule 15 (expr_stmt -> augassign .)


state 19

    (16) expr_stmt -> annassign .

    NEWLINE         reduce using rule 16 (expr_stmt -> annassign .)
    IF              reduce using rule 16 (expr_stmt -> annassign .)
    FOR             reduce using rule 16 (expr_stmt -> annassign .)
    BREAK           reduce using rule 16 (expr_stmt -> annassign .)
    PRINT           reduce using rule 16 (expr_stmt -> annassign .)
    CDEF            reduce using rule 16 (expr_stmt -> annassign .)
    NOT             reduce using rule 16 (expr_stmt -> annassign .)
    LPAREN          reduce using rule 16 (expr_stmt -> annassign .)
    ID              reduce using rule 16 (expr_stmt -> annassign .)
    NUMBER          reduce using rule 16 (expr_stmt -> annassign .)
    STRING          reduce using rule 16 (expr_stmt -> annassign .)
    BOOL_TRUE       reduce using rule 16 (expr_stmt -> annassign .)
    BOOL_FALSE      reduce using rule 16 (expr_stmt -> annassign .)
    NONE            reduce using rule 16 (expr_stmt -> annassign .)
    $end            reduce using rule 16 (expr_stmt -> annassign .)
    ELIF            reduce using rule 16 (expr_stmt -> annassign .)
    ELSE            reduce using rule 16 (expr_stmt -> annassign .)


state 20

    (12) print_stmt -> PRINT . LPAREN test RPAREN

    LPAREN          shift and go to state 56


state 21

    (85) factor -> LPAREN . MINUS factor RPAREN

    MINUS           shift and go to state 57


state 22

    (92) atom -> STRING .

    TIMES           reduce using rule 92 (atom -> STRING .)
    DIVIDE          reduce using rule 92 (atom -> STRING .)
    MODULE          reduce using rule 92 (atom -> STRING .)
    POWER           reduce using rule 92 (atom -> STRING .)
    PLUS            reduce using rule 92 (atom -> STRING .)
    MINUS           reduce using rule 92 (atom -> STRING .)
    LESS_THAN       reduce using rule 92 (atom -> STRING .)
    MORE_THAN       reduce using rule 92 (atom -> STRING .)
    EQUALS          reduce using rule 92 (atom -> STRING .)
    MORE_EQUAL      reduce using rule 92 (atom -> STRING .)
    LESS_EQUAL      reduce using rule 92 (atom -> STRING .)
    NOT_EQUAL       reduce using rule 92 (atom -> STRING .)
    IN              reduce using rule 92 (atom -> STRING .)
    NOT_IN          reduce using rule 92 (atom -> STRING .)
    IS              reduce using rule 92 (atom -> STRING .)
    IS_NOT          reduce using rule 92 (atom -> STRING .)
    AND             reduce using rule 92 (atom -> STRING .)
    OR              reduce using rule 92 (atom -> STRING .)
    ASSIGN          reduce using rule 92 (atom -> STRING .)
    PLUS_ASSIGN     reduce using rule 92 (atom -> STRING .)
    MINUS_ASSIGN    reduce using rule 92 (atom -> STRING .)
    TIMES_ASSIGN    reduce using rule 92 (atom -> STRING .)
    DIVIDE_ASSIGN   reduce using rule 92 (atom -> STRING .)
    ASSIGN_MODULE   reduce using rule 92 (atom -> STRING .)
    THEN            reduce using rule 92 (atom -> STRING .)
    NEWLINE         reduce using rule 92 (atom -> STRING .)
    IF              reduce using rule 92 (atom -> STRING .)
    FOR             reduce using rule 92 (atom -> STRING .)
    BREAK           reduce using rule 92 (atom -> STRING .)
    PRINT           reduce using rule 92 (atom -> STRING .)
    CDEF            reduce using rule 92 (atom -> STRING .)
    NOT             reduce using rule 92 (atom -> STRING .)
    LPAREN          reduce using rule 92 (atom -> STRING .)
    ID              reduce using rule 92 (atom -> STRING .)
    NUMBER          reduce using rule 92 (atom -> STRING .)
    STRING          reduce using rule 92 (atom -> STRING .)
    BOOL_TRUE       reduce using rule 92 (atom -> STRING .)
    BOOL_FALSE      reduce using rule 92 (atom -> STRING .)
    NONE            reduce using rule 92 (atom -> STRING .)
    $end            reduce using rule 92 (atom -> STRING .)
    ELIF            reduce using rule 92 (atom -> STRING .)
    ELSE            reduce using rule 92 (atom -> STRING .)
    RPAREN          reduce using rule 92 (atom -> STRING .)


state 23

    (17) typotest -> CDEF . vartypes
    (18) vartypes -> . INT test ASSIGN test
    (19) vartypes -> . DOUBLE test ASSIGN test
    (20) vartypes -> . SHORT test ASSIGN test
    (21) vartypes -> . LONG test ASSIGN test
    (22) vartypes -> . CHAR test ASSIGN test
    (23) vartypes -> . FLOAT test ASSIGN test

    INT             shift and go to state 59
    DOUBLE          shift and go to state 60
    SHORT           shift and go to state 61
    LONG            shift and go to state 62
    CHAR            shift and go to state 63
    FLOAT           shift and go to state 64

    vartypes                       shift and go to state 58

state 24

    (55) test -> or_test .

    ASSIGN          reduce using rule 55 (test -> or_test .)
    PLUS_ASSIGN     reduce using rule 55 (test -> or_test .)
    MINUS_ASSIGN    reduce using rule 55 (test -> or_test .)
    TIMES_ASSIGN    reduce using rule 55 (test -> or_test .)
    DIVIDE_ASSIGN   reduce using rule 55 (test -> or_test .)
    ASSIGN_MODULE   reduce using rule 55 (test -> or_test .)
    THEN            reduce using rule 55 (test -> or_test .)
    NEWLINE         reduce using rule 55 (test -> or_test .)
    IF              reduce using rule 55 (test -> or_test .)
    FOR             reduce using rule 55 (test -> or_test .)
    BREAK           reduce using rule 55 (test -> or_test .)
    PRINT           reduce using rule 55 (test -> or_test .)
    CDEF            reduce using rule 55 (test -> or_test .)
    NOT             reduce using rule 55 (test -> or_test .)
    LPAREN          reduce using rule 55 (test -> or_test .)
    ID              reduce using rule 55 (test -> or_test .)
    NUMBER          reduce using rule 55 (test -> or_test .)
    STRING          reduce using rule 55 (test -> or_test .)
    BOOL_TRUE       reduce using rule 55 (test -> or_test .)
    BOOL_FALSE      reduce using rule 55 (test -> or_test .)
    NONE            reduce using rule 55 (test -> or_test .)
    $end            reduce using rule 55 (test -> or_test .)
    ELIF            reduce using rule 55 (test -> or_test .)
    ELSE            reduce using rule 55 (test -> or_test .)
    RPAREN          reduce using rule 55 (test -> or_test .)


state 25

    (56) or_test -> and_test . or_comp
    (57) or_comp -> . OR and_test or_comp
    (58) or_comp -> . empty
    (96) empty -> .

    OR              shift and go to state 66
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    or_comp                        shift and go to state 65
    empty                          shift and go to state 67

state 26

    (59) and_test -> not_test . and_comp
    (60) and_comp -> . AND not_test and_comp
    (61) and_comp -> . empty
    (96) empty -> .

    AND             shift and go to state 69
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    and_comp                       shift and go to state 68
    empty                          shift and go to state 70

state 27

    (62) not_test -> NOT . not_test
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    not_test                       shift and go to state 71
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 28

    (63) not_test -> comparison .

    AND             reduce using rule 63 (not_test -> comparison .)
    OR              reduce using rule 63 (not_test -> comparison .)
    ASSIGN          reduce using rule 63 (not_test -> comparison .)
    PLUS_ASSIGN     reduce using rule 63 (not_test -> comparison .)
    MINUS_ASSIGN    reduce using rule 63 (not_test -> comparison .)
    TIMES_ASSIGN    reduce using rule 63 (not_test -> comparison .)
    DIVIDE_ASSIGN   reduce using rule 63 (not_test -> comparison .)
    ASSIGN_MODULE   reduce using rule 63 (not_test -> comparison .)
    THEN            reduce using rule 63 (not_test -> comparison .)
    NEWLINE         reduce using rule 63 (not_test -> comparison .)
    IF              reduce using rule 63 (not_test -> comparison .)
    FOR             reduce using rule 63 (not_test -> comparison .)
    BREAK           reduce using rule 63 (not_test -> comparison .)
    PRINT           reduce using rule 63 (not_test -> comparison .)
    CDEF            reduce using rule 63 (not_test -> comparison .)
    NOT             reduce using rule 63 (not_test -> comparison .)
    LPAREN          reduce using rule 63 (not_test -> comparison .)
    ID              reduce using rule 63 (not_test -> comparison .)
    NUMBER          reduce using rule 63 (not_test -> comparison .)
    STRING          reduce using rule 63 (not_test -> comparison .)
    BOOL_TRUE       reduce using rule 63 (not_test -> comparison .)
    BOOL_FALSE      reduce using rule 63 (not_test -> comparison .)
    NONE            reduce using rule 63 (not_test -> comparison .)
    $end            reduce using rule 63 (not_test -> comparison .)
    ELIF            reduce using rule 63 (not_test -> comparison .)
    ELSE            reduce using rule 63 (not_test -> comparison .)
    RPAREN          reduce using rule 63 (not_test -> comparison .)


state 29

    (64) comparison -> expression . comphelper
    (65) comphelper -> . comp_op expression comphelper
    (66) comphelper -> . empty
    (67) comp_op -> . LESS_THAN
    (68) comp_op -> . MORE_THAN
    (69) comp_op -> . EQUALS
    (70) comp_op -> . MORE_EQUAL
    (71) comp_op -> . LESS_EQUAL
    (72) comp_op -> . NOT_EQUAL
    (73) comp_op -> . IN
    (74) comp_op -> . NOT_IN
    (75) comp_op -> . IS
    (76) comp_op -> . IS_NOT
    (96) empty -> .

    LESS_THAN       shift and go to state 75
    MORE_THAN       shift and go to state 76
    EQUALS          shift and go to state 77
    MORE_EQUAL      shift and go to state 78
    LESS_EQUAL      shift and go to state 79
    NOT_EQUAL       shift and go to state 80
    IN              shift and go to state 81
    NOT_IN          shift and go to state 82
    IS              shift and go to state 83
    IS_NOT          shift and go to state 84
    AND             reduce using rule 96 (empty -> .)
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    comphelper                     shift and go to state 72
    comp_op                        shift and go to state 73
    empty                          shift and go to state 74

state 30

    (77) expression -> arith_expr .

    LESS_THAN       reduce using rule 77 (expression -> arith_expr .)
    MORE_THAN       reduce using rule 77 (expression -> arith_expr .)
    EQUALS          reduce using rule 77 (expression -> arith_expr .)
    MORE_EQUAL      reduce using rule 77 (expression -> arith_expr .)
    LESS_EQUAL      reduce using rule 77 (expression -> arith_expr .)
    NOT_EQUAL       reduce using rule 77 (expression -> arith_expr .)
    IN              reduce using rule 77 (expression -> arith_expr .)
    NOT_IN          reduce using rule 77 (expression -> arith_expr .)
    IS              reduce using rule 77 (expression -> arith_expr .)
    IS_NOT          reduce using rule 77 (expression -> arith_expr .)
    AND             reduce using rule 77 (expression -> arith_expr .)
    OR              reduce using rule 77 (expression -> arith_expr .)
    ASSIGN          reduce using rule 77 (expression -> arith_expr .)
    PLUS_ASSIGN     reduce using rule 77 (expression -> arith_expr .)
    MINUS_ASSIGN    reduce using rule 77 (expression -> arith_expr .)
    TIMES_ASSIGN    reduce using rule 77 (expression -> arith_expr .)
    DIVIDE_ASSIGN   reduce using rule 77 (expression -> arith_expr .)
    ASSIGN_MODULE   reduce using rule 77 (expression -> arith_expr .)
    THEN            reduce using rule 77 (expression -> arith_expr .)
    NEWLINE         reduce using rule 77 (expression -> arith_expr .)
    IF              reduce using rule 77 (expression -> arith_expr .)
    FOR             reduce using rule 77 (expression -> arith_expr .)
    BREAK           reduce using rule 77 (expression -> arith_expr .)
    PRINT           reduce using rule 77 (expression -> arith_expr .)
    CDEF            reduce using rule 77 (expression -> arith_expr .)
    NOT             reduce using rule 77 (expression -> arith_expr .)
    LPAREN          reduce using rule 77 (expression -> arith_expr .)
    ID              reduce using rule 77 (expression -> arith_expr .)
    NUMBER          reduce using rule 77 (expression -> arith_expr .)
    STRING          reduce using rule 77 (expression -> arith_expr .)
    BOOL_TRUE       reduce using rule 77 (expression -> arith_expr .)
    BOOL_FALSE      reduce using rule 77 (expression -> arith_expr .)
    NONE            reduce using rule 77 (expression -> arith_expr .)
    $end            reduce using rule 77 (expression -> arith_expr .)
    ELIF            reduce using rule 77 (expression -> arith_expr .)
    ELSE            reduce using rule 77 (expression -> arith_expr .)
    RPAREN          reduce using rule 77 (expression -> arith_expr .)


state 31

    (78) arith_expr -> term . PLUS arith_expr
    (79) arith_expr -> term . MINUS arith_expr
    (80) arith_expr -> term . empty
    (96) empty -> .

    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    LESS_THAN       reduce using rule 96 (empty -> .)
    MORE_THAN       reduce using rule 96 (empty -> .)
    EQUALS          reduce using rule 96 (empty -> .)
    MORE_EQUAL      reduce using rule 96 (empty -> .)
    LESS_EQUAL      reduce using rule 96 (empty -> .)
    NOT_EQUAL       reduce using rule 96 (empty -> .)
    IN              reduce using rule 96 (empty -> .)
    NOT_IN          reduce using rule 96 (empty -> .)
    IS              reduce using rule 96 (empty -> .)
    IS_NOT          reduce using rule 96 (empty -> .)
    AND             reduce using rule 96 (empty -> .)
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 87

state 32

    (81) term -> factor . TIMES term
    (82) term -> factor . DIVIDE term
    (83) term -> factor . MODULE term
    (84) term -> factor . empty
    (87) power -> factor . POWER factor
    (96) empty -> .

    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    POWER           shift and go to state 92
    PLUS            reduce using rule 96 (empty -> .)
    MINUS           reduce using rule 96 (empty -> .)
    LESS_THAN       reduce using rule 96 (empty -> .)
    MORE_THAN       reduce using rule 96 (empty -> .)
    EQUALS          reduce using rule 96 (empty -> .)
    MORE_EQUAL      reduce using rule 96 (empty -> .)
    LESS_EQUAL      reduce using rule 96 (empty -> .)
    NOT_EQUAL       reduce using rule 96 (empty -> .)
    IN              reduce using rule 96 (empty -> .)
    NOT_IN          reduce using rule 96 (empty -> .)
    IS              reduce using rule 96 (empty -> .)
    IS_NOT          reduce using rule 96 (empty -> .)
    AND             reduce using rule 96 (empty -> .)
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 91

state 33

    (86) factor -> power .

    TIMES           reduce using rule 86 (factor -> power .)
    DIVIDE          reduce using rule 86 (factor -> power .)
    MODULE          reduce using rule 86 (factor -> power .)
    POWER           reduce using rule 86 (factor -> power .)
    PLUS            reduce using rule 86 (factor -> power .)
    MINUS           reduce using rule 86 (factor -> power .)
    LESS_THAN       reduce using rule 86 (factor -> power .)
    MORE_THAN       reduce using rule 86 (factor -> power .)
    EQUALS          reduce using rule 86 (factor -> power .)
    MORE_EQUAL      reduce using rule 86 (factor -> power .)
    LESS_EQUAL      reduce using rule 86 (factor -> power .)
    NOT_EQUAL       reduce using rule 86 (factor -> power .)
    IN              reduce using rule 86 (factor -> power .)
    NOT_IN          reduce using rule 86 (factor -> power .)
    IS              reduce using rule 86 (factor -> power .)
    IS_NOT          reduce using rule 86 (factor -> power .)
    AND             reduce using rule 86 (factor -> power .)
    OR              reduce using rule 86 (factor -> power .)
    ASSIGN          reduce using rule 86 (factor -> power .)
    PLUS_ASSIGN     reduce using rule 86 (factor -> power .)
    MINUS_ASSIGN    reduce using rule 86 (factor -> power .)
    TIMES_ASSIGN    reduce using rule 86 (factor -> power .)
    DIVIDE_ASSIGN   reduce using rule 86 (factor -> power .)
    ASSIGN_MODULE   reduce using rule 86 (factor -> power .)
    THEN            reduce using rule 86 (factor -> power .)
    NEWLINE         reduce using rule 86 (factor -> power .)
    IF              reduce using rule 86 (factor -> power .)
    FOR             reduce using rule 86 (factor -> power .)
    BREAK           reduce using rule 86 (factor -> power .)
    PRINT           reduce using rule 86 (factor -> power .)
    CDEF            reduce using rule 86 (factor -> power .)
    NOT             reduce using rule 86 (factor -> power .)
    LPAREN          reduce using rule 86 (factor -> power .)
    ID              reduce using rule 86 (factor -> power .)
    NUMBER          reduce using rule 86 (factor -> power .)
    STRING          reduce using rule 86 (factor -> power .)
    BOOL_TRUE       reduce using rule 86 (factor -> power .)
    BOOL_FALSE      reduce using rule 86 (factor -> power .)
    NONE            reduce using rule 86 (factor -> power .)
    $end            reduce using rule 86 (factor -> power .)
    ELIF            reduce using rule 86 (factor -> power .)
    ELSE            reduce using rule 86 (factor -> power .)
    RPAREN          reduce using rule 86 (factor -> power .)


state 34

    (88) power -> atom_expr . empty
    (96) empty -> .

    TIMES           reduce using rule 96 (empty -> .)
    DIVIDE          reduce using rule 96 (empty -> .)
    MODULE          reduce using rule 96 (empty -> .)
    POWER           reduce using rule 96 (empty -> .)
    PLUS            reduce using rule 96 (empty -> .)
    MINUS           reduce using rule 96 (empty -> .)
    LESS_THAN       reduce using rule 96 (empty -> .)
    MORE_THAN       reduce using rule 96 (empty -> .)
    EQUALS          reduce using rule 96 (empty -> .)
    MORE_EQUAL      reduce using rule 96 (empty -> .)
    LESS_EQUAL      reduce using rule 96 (empty -> .)
    NOT_EQUAL       reduce using rule 96 (empty -> .)
    IN              reduce using rule 96 (empty -> .)
    NOT_IN          reduce using rule 96 (empty -> .)
    IS              reduce using rule 96 (empty -> .)
    IS_NOT          reduce using rule 96 (empty -> .)
    AND             reduce using rule 96 (empty -> .)
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 93

state 35

    (89) atom_expr -> atom .

    TIMES           reduce using rule 89 (atom_expr -> atom .)
    DIVIDE          reduce using rule 89 (atom_expr -> atom .)
    MODULE          reduce using rule 89 (atom_expr -> atom .)
    POWER           reduce using rule 89 (atom_expr -> atom .)
    PLUS            reduce using rule 89 (atom_expr -> atom .)
    MINUS           reduce using rule 89 (atom_expr -> atom .)
    LESS_THAN       reduce using rule 89 (atom_expr -> atom .)
    MORE_THAN       reduce using rule 89 (atom_expr -> atom .)
    EQUALS          reduce using rule 89 (atom_expr -> atom .)
    MORE_EQUAL      reduce using rule 89 (atom_expr -> atom .)
    LESS_EQUAL      reduce using rule 89 (atom_expr -> atom .)
    NOT_EQUAL       reduce using rule 89 (atom_expr -> atom .)
    IN              reduce using rule 89 (atom_expr -> atom .)
    NOT_IN          reduce using rule 89 (atom_expr -> atom .)
    IS              reduce using rule 89 (atom_expr -> atom .)
    IS_NOT          reduce using rule 89 (atom_expr -> atom .)
    AND             reduce using rule 89 (atom_expr -> atom .)
    OR              reduce using rule 89 (atom_expr -> atom .)
    ASSIGN          reduce using rule 89 (atom_expr -> atom .)
    PLUS_ASSIGN     reduce using rule 89 (atom_expr -> atom .)
    MINUS_ASSIGN    reduce using rule 89 (atom_expr -> atom .)
    TIMES_ASSIGN    reduce using rule 89 (atom_expr -> atom .)
    DIVIDE_ASSIGN   reduce using rule 89 (atom_expr -> atom .)
    ASSIGN_MODULE   reduce using rule 89 (atom_expr -> atom .)
    THEN            reduce using rule 89 (atom_expr -> atom .)
    NEWLINE         reduce using rule 89 (atom_expr -> atom .)
    IF              reduce using rule 89 (atom_expr -> atom .)
    FOR             reduce using rule 89 (atom_expr -> atom .)
    BREAK           reduce using rule 89 (atom_expr -> atom .)
    PRINT           reduce using rule 89 (atom_expr -> atom .)
    CDEF            reduce using rule 89 (atom_expr -> atom .)
    NOT             reduce using rule 89 (atom_expr -> atom .)
    LPAREN          reduce using rule 89 (atom_expr -> atom .)
    ID              reduce using rule 89 (atom_expr -> atom .)
    NUMBER          reduce using rule 89 (atom_expr -> atom .)
    STRING          reduce using rule 89 (atom_expr -> atom .)
    BOOL_TRUE       reduce using rule 89 (atom_expr -> atom .)
    BOOL_FALSE      reduce using rule 89 (atom_expr -> atom .)
    NONE            reduce using rule 89 (atom_expr -> atom .)
    $end            reduce using rule 89 (atom_expr -> atom .)
    ELIF            reduce using rule 89 (atom_expr -> atom .)
    ELSE            reduce using rule 89 (atom_expr -> atom .)
    RPAREN          reduce using rule 89 (atom_expr -> atom .)


state 36

    (90) atom -> ID .

    TIMES           reduce using rule 90 (atom -> ID .)
    DIVIDE          reduce using rule 90 (atom -> ID .)
    MODULE          reduce using rule 90 (atom -> ID .)
    POWER           reduce using rule 90 (atom -> ID .)
    PLUS            reduce using rule 90 (atom -> ID .)
    MINUS           reduce using rule 90 (atom -> ID .)
    LESS_THAN       reduce using rule 90 (atom -> ID .)
    MORE_THAN       reduce using rule 90 (atom -> ID .)
    EQUALS          reduce using rule 90 (atom -> ID .)
    MORE_EQUAL      reduce using rule 90 (atom -> ID .)
    LESS_EQUAL      reduce using rule 90 (atom -> ID .)
    NOT_EQUAL       reduce using rule 90 (atom -> ID .)
    IN              reduce using rule 90 (atom -> ID .)
    NOT_IN          reduce using rule 90 (atom -> ID .)
    IS              reduce using rule 90 (atom -> ID .)
    IS_NOT          reduce using rule 90 (atom -> ID .)
    AND             reduce using rule 90 (atom -> ID .)
    OR              reduce using rule 90 (atom -> ID .)
    ASSIGN          reduce using rule 90 (atom -> ID .)
    PLUS_ASSIGN     reduce using rule 90 (atom -> ID .)
    MINUS_ASSIGN    reduce using rule 90 (atom -> ID .)
    TIMES_ASSIGN    reduce using rule 90 (atom -> ID .)
    DIVIDE_ASSIGN   reduce using rule 90 (atom -> ID .)
    ASSIGN_MODULE   reduce using rule 90 (atom -> ID .)
    THEN            reduce using rule 90 (atom -> ID .)
    NEWLINE         reduce using rule 90 (atom -> ID .)
    IF              reduce using rule 90 (atom -> ID .)
    FOR             reduce using rule 90 (atom -> ID .)
    BREAK           reduce using rule 90 (atom -> ID .)
    PRINT           reduce using rule 90 (atom -> ID .)
    CDEF            reduce using rule 90 (atom -> ID .)
    NOT             reduce using rule 90 (atom -> ID .)
    LPAREN          reduce using rule 90 (atom -> ID .)
    ID              reduce using rule 90 (atom -> ID .)
    NUMBER          reduce using rule 90 (atom -> ID .)
    STRING          reduce using rule 90 (atom -> ID .)
    BOOL_TRUE       reduce using rule 90 (atom -> ID .)
    BOOL_FALSE      reduce using rule 90 (atom -> ID .)
    NONE            reduce using rule 90 (atom -> ID .)
    $end            reduce using rule 90 (atom -> ID .)
    ELIF            reduce using rule 90 (atom -> ID .)
    ELSE            reduce using rule 90 (atom -> ID .)
    RPAREN          reduce using rule 90 (atom -> ID .)


state 37

    (91) atom -> NUMBER .

    TIMES           reduce using rule 91 (atom -> NUMBER .)
    DIVIDE          reduce using rule 91 (atom -> NUMBER .)
    MODULE          reduce using rule 91 (atom -> NUMBER .)
    POWER           reduce using rule 91 (atom -> NUMBER .)
    PLUS            reduce using rule 91 (atom -> NUMBER .)
    MINUS           reduce using rule 91 (atom -> NUMBER .)
    LESS_THAN       reduce using rule 91 (atom -> NUMBER .)
    MORE_THAN       reduce using rule 91 (atom -> NUMBER .)
    EQUALS          reduce using rule 91 (atom -> NUMBER .)
    MORE_EQUAL      reduce using rule 91 (atom -> NUMBER .)
    LESS_EQUAL      reduce using rule 91 (atom -> NUMBER .)
    NOT_EQUAL       reduce using rule 91 (atom -> NUMBER .)
    IN              reduce using rule 91 (atom -> NUMBER .)
    NOT_IN          reduce using rule 91 (atom -> NUMBER .)
    IS              reduce using rule 91 (atom -> NUMBER .)
    IS_NOT          reduce using rule 91 (atom -> NUMBER .)
    AND             reduce using rule 91 (atom -> NUMBER .)
    OR              reduce using rule 91 (atom -> NUMBER .)
    ASSIGN          reduce using rule 91 (atom -> NUMBER .)
    PLUS_ASSIGN     reduce using rule 91 (atom -> NUMBER .)
    MINUS_ASSIGN    reduce using rule 91 (atom -> NUMBER .)
    TIMES_ASSIGN    reduce using rule 91 (atom -> NUMBER .)
    DIVIDE_ASSIGN   reduce using rule 91 (atom -> NUMBER .)
    ASSIGN_MODULE   reduce using rule 91 (atom -> NUMBER .)
    THEN            reduce using rule 91 (atom -> NUMBER .)
    NEWLINE         reduce using rule 91 (atom -> NUMBER .)
    IF              reduce using rule 91 (atom -> NUMBER .)
    FOR             reduce using rule 91 (atom -> NUMBER .)
    BREAK           reduce using rule 91 (atom -> NUMBER .)
    PRINT           reduce using rule 91 (atom -> NUMBER .)
    CDEF            reduce using rule 91 (atom -> NUMBER .)
    NOT             reduce using rule 91 (atom -> NUMBER .)
    LPAREN          reduce using rule 91 (atom -> NUMBER .)
    ID              reduce using rule 91 (atom -> NUMBER .)
    NUMBER          reduce using rule 91 (atom -> NUMBER .)
    STRING          reduce using rule 91 (atom -> NUMBER .)
    BOOL_TRUE       reduce using rule 91 (atom -> NUMBER .)
    BOOL_FALSE      reduce using rule 91 (atom -> NUMBER .)
    NONE            reduce using rule 91 (atom -> NUMBER .)
    $end            reduce using rule 91 (atom -> NUMBER .)
    ELIF            reduce using rule 91 (atom -> NUMBER .)
    ELSE            reduce using rule 91 (atom -> NUMBER .)
    RPAREN          reduce using rule 91 (atom -> NUMBER .)


state 38

    (93) atom -> BOOL_TRUE .

    TIMES           reduce using rule 93 (atom -> BOOL_TRUE .)
    DIVIDE          reduce using rule 93 (atom -> BOOL_TRUE .)
    MODULE          reduce using rule 93 (atom -> BOOL_TRUE .)
    POWER           reduce using rule 93 (atom -> BOOL_TRUE .)
    PLUS            reduce using rule 93 (atom -> BOOL_TRUE .)
    MINUS           reduce using rule 93 (atom -> BOOL_TRUE .)
    LESS_THAN       reduce using rule 93 (atom -> BOOL_TRUE .)
    MORE_THAN       reduce using rule 93 (atom -> BOOL_TRUE .)
    EQUALS          reduce using rule 93 (atom -> BOOL_TRUE .)
    MORE_EQUAL      reduce using rule 93 (atom -> BOOL_TRUE .)
    LESS_EQUAL      reduce using rule 93 (atom -> BOOL_TRUE .)
    NOT_EQUAL       reduce using rule 93 (atom -> BOOL_TRUE .)
    IN              reduce using rule 93 (atom -> BOOL_TRUE .)
    NOT_IN          reduce using rule 93 (atom -> BOOL_TRUE .)
    IS              reduce using rule 93 (atom -> BOOL_TRUE .)
    IS_NOT          reduce using rule 93 (atom -> BOOL_TRUE .)
    AND             reduce using rule 93 (atom -> BOOL_TRUE .)
    OR              reduce using rule 93 (atom -> BOOL_TRUE .)
    ASSIGN          reduce using rule 93 (atom -> BOOL_TRUE .)
    PLUS_ASSIGN     reduce using rule 93 (atom -> BOOL_TRUE .)
    MINUS_ASSIGN    reduce using rule 93 (atom -> BOOL_TRUE .)
    TIMES_ASSIGN    reduce using rule 93 (atom -> BOOL_TRUE .)
    DIVIDE_ASSIGN   reduce using rule 93 (atom -> BOOL_TRUE .)
    ASSIGN_MODULE   reduce using rule 93 (atom -> BOOL_TRUE .)
    THEN            reduce using rule 93 (atom -> BOOL_TRUE .)
    NEWLINE         reduce using rule 93 (atom -> BOOL_TRUE .)
    IF              reduce using rule 93 (atom -> BOOL_TRUE .)
    FOR             reduce using rule 93 (atom -> BOOL_TRUE .)
    BREAK           reduce using rule 93 (atom -> BOOL_TRUE .)
    PRINT           reduce using rule 93 (atom -> BOOL_TRUE .)
    CDEF            reduce using rule 93 (atom -> BOOL_TRUE .)
    NOT             reduce using rule 93 (atom -> BOOL_TRUE .)
    LPAREN          reduce using rule 93 (atom -> BOOL_TRUE .)
    ID              reduce using rule 93 (atom -> BOOL_TRUE .)
    NUMBER          reduce using rule 93 (atom -> BOOL_TRUE .)
    STRING          reduce using rule 93 (atom -> BOOL_TRUE .)
    BOOL_TRUE       reduce using rule 93 (atom -> BOOL_TRUE .)
    BOOL_FALSE      reduce using rule 93 (atom -> BOOL_TRUE .)
    NONE            reduce using rule 93 (atom -> BOOL_TRUE .)
    $end            reduce using rule 93 (atom -> BOOL_TRUE .)
    ELIF            reduce using rule 93 (atom -> BOOL_TRUE .)
    ELSE            reduce using rule 93 (atom -> BOOL_TRUE .)
    RPAREN          reduce using rule 93 (atom -> BOOL_TRUE .)


state 39

    (94) atom -> BOOL_FALSE .

    TIMES           reduce using rule 94 (atom -> BOOL_FALSE .)
    DIVIDE          reduce using rule 94 (atom -> BOOL_FALSE .)
    MODULE          reduce using rule 94 (atom -> BOOL_FALSE .)
    POWER           reduce using rule 94 (atom -> BOOL_FALSE .)
    PLUS            reduce using rule 94 (atom -> BOOL_FALSE .)
    MINUS           reduce using rule 94 (atom -> BOOL_FALSE .)
    LESS_THAN       reduce using rule 94 (atom -> BOOL_FALSE .)
    MORE_THAN       reduce using rule 94 (atom -> BOOL_FALSE .)
    EQUALS          reduce using rule 94 (atom -> BOOL_FALSE .)
    MORE_EQUAL      reduce using rule 94 (atom -> BOOL_FALSE .)
    LESS_EQUAL      reduce using rule 94 (atom -> BOOL_FALSE .)
    NOT_EQUAL       reduce using rule 94 (atom -> BOOL_FALSE .)
    IN              reduce using rule 94 (atom -> BOOL_FALSE .)
    NOT_IN          reduce using rule 94 (atom -> BOOL_FALSE .)
    IS              reduce using rule 94 (atom -> BOOL_FALSE .)
    IS_NOT          reduce using rule 94 (atom -> BOOL_FALSE .)
    AND             reduce using rule 94 (atom -> BOOL_FALSE .)
    OR              reduce using rule 94 (atom -> BOOL_FALSE .)
    ASSIGN          reduce using rule 94 (atom -> BOOL_FALSE .)
    PLUS_ASSIGN     reduce using rule 94 (atom -> BOOL_FALSE .)
    MINUS_ASSIGN    reduce using rule 94 (atom -> BOOL_FALSE .)
    TIMES_ASSIGN    reduce using rule 94 (atom -> BOOL_FALSE .)
    DIVIDE_ASSIGN   reduce using rule 94 (atom -> BOOL_FALSE .)
    ASSIGN_MODULE   reduce using rule 94 (atom -> BOOL_FALSE .)
    THEN            reduce using rule 94 (atom -> BOOL_FALSE .)
    NEWLINE         reduce using rule 94 (atom -> BOOL_FALSE .)
    IF              reduce using rule 94 (atom -> BOOL_FALSE .)
    FOR             reduce using rule 94 (atom -> BOOL_FALSE .)
    BREAK           reduce using rule 94 (atom -> BOOL_FALSE .)
    PRINT           reduce using rule 94 (atom -> BOOL_FALSE .)
    CDEF            reduce using rule 94 (atom -> BOOL_FALSE .)
    NOT             reduce using rule 94 (atom -> BOOL_FALSE .)
    LPAREN          reduce using rule 94 (atom -> BOOL_FALSE .)
    ID              reduce using rule 94 (atom -> BOOL_FALSE .)
    NUMBER          reduce using rule 94 (atom -> BOOL_FALSE .)
    STRING          reduce using rule 94 (atom -> BOOL_FALSE .)
    BOOL_TRUE       reduce using rule 94 (atom -> BOOL_FALSE .)
    BOOL_FALSE      reduce using rule 94 (atom -> BOOL_FALSE .)
    NONE            reduce using rule 94 (atom -> BOOL_FALSE .)
    $end            reduce using rule 94 (atom -> BOOL_FALSE .)
    ELIF            reduce using rule 94 (atom -> BOOL_FALSE .)
    ELSE            reduce using rule 94 (atom -> BOOL_FALSE .)
    RPAREN          reduce using rule 94 (atom -> BOOL_FALSE .)


state 40

    (95) atom -> NONE .

    TIMES           reduce using rule 95 (atom -> NONE .)
    DIVIDE          reduce using rule 95 (atom -> NONE .)
    MODULE          reduce using rule 95 (atom -> NONE .)
    POWER           reduce using rule 95 (atom -> NONE .)
    PLUS            reduce using rule 95 (atom -> NONE .)
    MINUS           reduce using rule 95 (atom -> NONE .)
    LESS_THAN       reduce using rule 95 (atom -> NONE .)
    MORE_THAN       reduce using rule 95 (atom -> NONE .)
    EQUALS          reduce using rule 95 (atom -> NONE .)
    MORE_EQUAL      reduce using rule 95 (atom -> NONE .)
    LESS_EQUAL      reduce using rule 95 (atom -> NONE .)
    NOT_EQUAL       reduce using rule 95 (atom -> NONE .)
    IN              reduce using rule 95 (atom -> NONE .)
    NOT_IN          reduce using rule 95 (atom -> NONE .)
    IS              reduce using rule 95 (atom -> NONE .)
    IS_NOT          reduce using rule 95 (atom -> NONE .)
    AND             reduce using rule 95 (atom -> NONE .)
    OR              reduce using rule 95 (atom -> NONE .)
    ASSIGN          reduce using rule 95 (atom -> NONE .)
    PLUS_ASSIGN     reduce using rule 95 (atom -> NONE .)
    MINUS_ASSIGN    reduce using rule 95 (atom -> NONE .)
    TIMES_ASSIGN    reduce using rule 95 (atom -> NONE .)
    DIVIDE_ASSIGN   reduce using rule 95 (atom -> NONE .)
    ASSIGN_MODULE   reduce using rule 95 (atom -> NONE .)
    THEN            reduce using rule 95 (atom -> NONE .)
    NEWLINE         reduce using rule 95 (atom -> NONE .)
    IF              reduce using rule 95 (atom -> NONE .)
    FOR             reduce using rule 95 (atom -> NONE .)
    BREAK           reduce using rule 95 (atom -> NONE .)
    PRINT           reduce using rule 95 (atom -> NONE .)
    CDEF            reduce using rule 95 (atom -> NONE .)
    NOT             reduce using rule 95 (atom -> NONE .)
    LPAREN          reduce using rule 95 (atom -> NONE .)
    ID              reduce using rule 95 (atom -> NONE .)
    NUMBER          reduce using rule 95 (atom -> NONE .)
    STRING          reduce using rule 95 (atom -> NONE .)
    BOOL_TRUE       reduce using rule 95 (atom -> NONE .)
    BOOL_FALSE      reduce using rule 95 (atom -> NONE .)
    NONE            reduce using rule 95 (atom -> NONE .)
    $end            reduce using rule 95 (atom -> NONE .)
    ELIF            reduce using rule 95 (atom -> NONE .)
    ELSE            reduce using rule 95 (atom -> NONE .)
    RPAREN          reduce using rule 95 (atom -> NONE .)


state 41

    (1) file_input -> stmt file_inputhelp .

    $end            reduce using rule 1 (file_input -> stmt file_inputhelp .)


state 42

    (2) file_inputhelp -> file_input .

    $end            reduce using rule 2 (file_inputhelp -> file_input .)


state 43

    (3) file_inputhelp -> empty .

    $end            reduce using rule 3 (file_inputhelp -> empty .)


state 44

    (6) simple_stmt -> small_stmt simplehelper .

    IF              reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    FOR             reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    BREAK           reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    PRINT           reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    CDEF            reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    NOT             reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    LPAREN          reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    ID              reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    NUMBER          reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    STRING          reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    BOOL_TRUE       reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    BOOL_FALSE      reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    NONE            reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    $end            reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    NEWLINE         reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    ELIF            reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)
    ELSE            reduce using rule 6 (simple_stmt -> small_stmt simplehelper .)


state 45

    (7) simplehelper -> NEWLINE . small_stmt simplehelper
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    small_stmt                     shift and go to state 94
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    test                           shift and go to state 13
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 46

    (8) simplehelper -> empty .

    IF              reduce using rule 8 (simplehelper -> empty .)
    FOR             reduce using rule 8 (simplehelper -> empty .)
    BREAK           reduce using rule 8 (simplehelper -> empty .)
    PRINT           reduce using rule 8 (simplehelper -> empty .)
    CDEF            reduce using rule 8 (simplehelper -> empty .)
    NOT             reduce using rule 8 (simplehelper -> empty .)
    LPAREN          reduce using rule 8 (simplehelper -> empty .)
    ID              reduce using rule 8 (simplehelper -> empty .)
    NUMBER          reduce using rule 8 (simplehelper -> empty .)
    STRING          reduce using rule 8 (simplehelper -> empty .)
    BOOL_TRUE       reduce using rule 8 (simplehelper -> empty .)
    BOOL_FALSE      reduce using rule 8 (simplehelper -> empty .)
    NONE            reduce using rule 8 (simplehelper -> empty .)
    $end            reduce using rule 8 (simplehelper -> empty .)
    NEWLINE         reduce using rule 8 (simplehelper -> empty .)
    ELIF            reduce using rule 8 (simplehelper -> empty .)
    ELSE            reduce using rule 8 (simplehelper -> empty .)


state 47

    (34) if_stmnt -> IF test . THEN suite NEWLINE
    (36) compound_if -> IF test . THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> IF test . THEN itersuite if_stmnt else_stmnt

    THEN            shift and go to state 95


state 48

    (13) input_stmt -> test ASSIGN . INPUT LPAREN STRING RPAREN
    (24) annassign -> test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    INPUT           shift and go to state 97
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 96
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 49

    (25) augassign -> test PLUS_ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 98
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 50

    (26) augassign -> test MINUS_ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 99
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 51

    (27) augassign -> test TIMES_ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 100
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 52

    (28) augassign -> test DIVIDE_ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 101
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 53

    (29) augassign -> test ASSIGN_MODULE . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 102
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 54

    (45) for_stmt -> FOR exprlist . IN testlist THEN stmt
    (46) for_stmt -> FOR exprlist . IN RANGE THEN stmt

    IN              shift and go to state 103


state 55

    (47) exprlist -> expression . exprlisthelper
    (48) exprlisthelper -> . NEWLINE expression exprlisthelper
    (49) exprlisthelper -> . empty
    (96) empty -> .

    NEWLINE         shift and go to state 105
    IN              reduce using rule 96 (empty -> .)

    exprlisthelper                 shift and go to state 104
    empty                          shift and go to state 106

state 56

    (12) print_stmt -> PRINT LPAREN . test RPAREN
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 107
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 57

    (85) factor -> LPAREN MINUS . factor RPAREN
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    factor                         shift and go to state 108
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 58

    (17) typotest -> CDEF vartypes .

    NEWLINE         reduce using rule 17 (typotest -> CDEF vartypes .)
    IF              reduce using rule 17 (typotest -> CDEF vartypes .)
    FOR             reduce using rule 17 (typotest -> CDEF vartypes .)
    BREAK           reduce using rule 17 (typotest -> CDEF vartypes .)
    PRINT           reduce using rule 17 (typotest -> CDEF vartypes .)
    CDEF            reduce using rule 17 (typotest -> CDEF vartypes .)
    NOT             reduce using rule 17 (typotest -> CDEF vartypes .)
    LPAREN          reduce using rule 17 (typotest -> CDEF vartypes .)
    ID              reduce using rule 17 (typotest -> CDEF vartypes .)
    NUMBER          reduce using rule 17 (typotest -> CDEF vartypes .)
    STRING          reduce using rule 17 (typotest -> CDEF vartypes .)
    BOOL_TRUE       reduce using rule 17 (typotest -> CDEF vartypes .)
    BOOL_FALSE      reduce using rule 17 (typotest -> CDEF vartypes .)
    NONE            reduce using rule 17 (typotest -> CDEF vartypes .)
    $end            reduce using rule 17 (typotest -> CDEF vartypes .)
    ELIF            reduce using rule 17 (typotest -> CDEF vartypes .)
    ELSE            reduce using rule 17 (typotest -> CDEF vartypes .)


state 59

    (18) vartypes -> INT . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 109
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 60

    (19) vartypes -> DOUBLE . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 110
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 61

    (20) vartypes -> SHORT . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 111
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 62

    (21) vartypes -> LONG . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 112
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 63

    (22) vartypes -> CHAR . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 113
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 64

    (23) vartypes -> FLOAT . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 114
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 65

    (56) or_test -> and_test or_comp .

    ASSIGN          reduce using rule 56 (or_test -> and_test or_comp .)
    PLUS_ASSIGN     reduce using rule 56 (or_test -> and_test or_comp .)
    MINUS_ASSIGN    reduce using rule 56 (or_test -> and_test or_comp .)
    TIMES_ASSIGN    reduce using rule 56 (or_test -> and_test or_comp .)
    DIVIDE_ASSIGN   reduce using rule 56 (or_test -> and_test or_comp .)
    ASSIGN_MODULE   reduce using rule 56 (or_test -> and_test or_comp .)
    THEN            reduce using rule 56 (or_test -> and_test or_comp .)
    NEWLINE         reduce using rule 56 (or_test -> and_test or_comp .)
    IF              reduce using rule 56 (or_test -> and_test or_comp .)
    FOR             reduce using rule 56 (or_test -> and_test or_comp .)
    BREAK           reduce using rule 56 (or_test -> and_test or_comp .)
    PRINT           reduce using rule 56 (or_test -> and_test or_comp .)
    CDEF            reduce using rule 56 (or_test -> and_test or_comp .)
    NOT             reduce using rule 56 (or_test -> and_test or_comp .)
    LPAREN          reduce using rule 56 (or_test -> and_test or_comp .)
    ID              reduce using rule 56 (or_test -> and_test or_comp .)
    NUMBER          reduce using rule 56 (or_test -> and_test or_comp .)
    STRING          reduce using rule 56 (or_test -> and_test or_comp .)
    BOOL_TRUE       reduce using rule 56 (or_test -> and_test or_comp .)
    BOOL_FALSE      reduce using rule 56 (or_test -> and_test or_comp .)
    NONE            reduce using rule 56 (or_test -> and_test or_comp .)
    $end            reduce using rule 56 (or_test -> and_test or_comp .)
    ELIF            reduce using rule 56 (or_test -> and_test or_comp .)
    ELSE            reduce using rule 56 (or_test -> and_test or_comp .)
    RPAREN          reduce using rule 56 (or_test -> and_test or_comp .)


state 66

    (57) or_comp -> OR . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    and_test                       shift and go to state 115
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 67

    (58) or_comp -> empty .

    ASSIGN          reduce using rule 58 (or_comp -> empty .)
    PLUS_ASSIGN     reduce using rule 58 (or_comp -> empty .)
    MINUS_ASSIGN    reduce using rule 58 (or_comp -> empty .)
    TIMES_ASSIGN    reduce using rule 58 (or_comp -> empty .)
    DIVIDE_ASSIGN   reduce using rule 58 (or_comp -> empty .)
    ASSIGN_MODULE   reduce using rule 58 (or_comp -> empty .)
    THEN            reduce using rule 58 (or_comp -> empty .)
    NEWLINE         reduce using rule 58 (or_comp -> empty .)
    IF              reduce using rule 58 (or_comp -> empty .)
    FOR             reduce using rule 58 (or_comp -> empty .)
    BREAK           reduce using rule 58 (or_comp -> empty .)
    PRINT           reduce using rule 58 (or_comp -> empty .)
    CDEF            reduce using rule 58 (or_comp -> empty .)
    NOT             reduce using rule 58 (or_comp -> empty .)
    LPAREN          reduce using rule 58 (or_comp -> empty .)
    ID              reduce using rule 58 (or_comp -> empty .)
    NUMBER          reduce using rule 58 (or_comp -> empty .)
    STRING          reduce using rule 58 (or_comp -> empty .)
    BOOL_TRUE       reduce using rule 58 (or_comp -> empty .)
    BOOL_FALSE      reduce using rule 58 (or_comp -> empty .)
    NONE            reduce using rule 58 (or_comp -> empty .)
    $end            reduce using rule 58 (or_comp -> empty .)
    ELIF            reduce using rule 58 (or_comp -> empty .)
    ELSE            reduce using rule 58 (or_comp -> empty .)
    RPAREN          reduce using rule 58 (or_comp -> empty .)


state 68

    (59) and_test -> not_test and_comp .

    OR              reduce using rule 59 (and_test -> not_test and_comp .)
    ASSIGN          reduce using rule 59 (and_test -> not_test and_comp .)
    PLUS_ASSIGN     reduce using rule 59 (and_test -> not_test and_comp .)
    MINUS_ASSIGN    reduce using rule 59 (and_test -> not_test and_comp .)
    TIMES_ASSIGN    reduce using rule 59 (and_test -> not_test and_comp .)
    DIVIDE_ASSIGN   reduce using rule 59 (and_test -> not_test and_comp .)
    ASSIGN_MODULE   reduce using rule 59 (and_test -> not_test and_comp .)
    THEN            reduce using rule 59 (and_test -> not_test and_comp .)
    NEWLINE         reduce using rule 59 (and_test -> not_test and_comp .)
    IF              reduce using rule 59 (and_test -> not_test and_comp .)
    FOR             reduce using rule 59 (and_test -> not_test and_comp .)
    BREAK           reduce using rule 59 (and_test -> not_test and_comp .)
    PRINT           reduce using rule 59 (and_test -> not_test and_comp .)
    CDEF            reduce using rule 59 (and_test -> not_test and_comp .)
    NOT             reduce using rule 59 (and_test -> not_test and_comp .)
    LPAREN          reduce using rule 59 (and_test -> not_test and_comp .)
    ID              reduce using rule 59 (and_test -> not_test and_comp .)
    NUMBER          reduce using rule 59 (and_test -> not_test and_comp .)
    STRING          reduce using rule 59 (and_test -> not_test and_comp .)
    BOOL_TRUE       reduce using rule 59 (and_test -> not_test and_comp .)
    BOOL_FALSE      reduce using rule 59 (and_test -> not_test and_comp .)
    NONE            reduce using rule 59 (and_test -> not_test and_comp .)
    $end            reduce using rule 59 (and_test -> not_test and_comp .)
    ELIF            reduce using rule 59 (and_test -> not_test and_comp .)
    ELSE            reduce using rule 59 (and_test -> not_test and_comp .)
    RPAREN          reduce using rule 59 (and_test -> not_test and_comp .)


state 69

    (60) and_comp -> AND . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    not_test                       shift and go to state 116
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 70

    (61) and_comp -> empty .

    OR              reduce using rule 61 (and_comp -> empty .)
    ASSIGN          reduce using rule 61 (and_comp -> empty .)
    PLUS_ASSIGN     reduce using rule 61 (and_comp -> empty .)
    MINUS_ASSIGN    reduce using rule 61 (and_comp -> empty .)
    TIMES_ASSIGN    reduce using rule 61 (and_comp -> empty .)
    DIVIDE_ASSIGN   reduce using rule 61 (and_comp -> empty .)
    ASSIGN_MODULE   reduce using rule 61 (and_comp -> empty .)
    THEN            reduce using rule 61 (and_comp -> empty .)
    NEWLINE         reduce using rule 61 (and_comp -> empty .)
    IF              reduce using rule 61 (and_comp -> empty .)
    FOR             reduce using rule 61 (and_comp -> empty .)
    BREAK           reduce using rule 61 (and_comp -> empty .)
    PRINT           reduce using rule 61 (and_comp -> empty .)
    CDEF            reduce using rule 61 (and_comp -> empty .)
    NOT             reduce using rule 61 (and_comp -> empty .)
    LPAREN          reduce using rule 61 (and_comp -> empty .)
    ID              reduce using rule 61 (and_comp -> empty .)
    NUMBER          reduce using rule 61 (and_comp -> empty .)
    STRING          reduce using rule 61 (and_comp -> empty .)
    BOOL_TRUE       reduce using rule 61 (and_comp -> empty .)
    BOOL_FALSE      reduce using rule 61 (and_comp -> empty .)
    NONE            reduce using rule 61 (and_comp -> empty .)
    $end            reduce using rule 61 (and_comp -> empty .)
    ELIF            reduce using rule 61 (and_comp -> empty .)
    ELSE            reduce using rule 61 (and_comp -> empty .)
    RPAREN          reduce using rule 61 (and_comp -> empty .)


state 71

    (62) not_test -> NOT not_test .

    AND             reduce using rule 62 (not_test -> NOT not_test .)
    OR              reduce using rule 62 (not_test -> NOT not_test .)
    ASSIGN          reduce using rule 62 (not_test -> NOT not_test .)
    PLUS_ASSIGN     reduce using rule 62 (not_test -> NOT not_test .)
    MINUS_ASSIGN    reduce using rule 62 (not_test -> NOT not_test .)
    TIMES_ASSIGN    reduce using rule 62 (not_test -> NOT not_test .)
    DIVIDE_ASSIGN   reduce using rule 62 (not_test -> NOT not_test .)
    ASSIGN_MODULE   reduce using rule 62 (not_test -> NOT not_test .)
    THEN            reduce using rule 62 (not_test -> NOT not_test .)
    NEWLINE         reduce using rule 62 (not_test -> NOT not_test .)
    IF              reduce using rule 62 (not_test -> NOT not_test .)
    FOR             reduce using rule 62 (not_test -> NOT not_test .)
    BREAK           reduce using rule 62 (not_test -> NOT not_test .)
    PRINT           reduce using rule 62 (not_test -> NOT not_test .)
    CDEF            reduce using rule 62 (not_test -> NOT not_test .)
    NOT             reduce using rule 62 (not_test -> NOT not_test .)
    LPAREN          reduce using rule 62 (not_test -> NOT not_test .)
    ID              reduce using rule 62 (not_test -> NOT not_test .)
    NUMBER          reduce using rule 62 (not_test -> NOT not_test .)
    STRING          reduce using rule 62 (not_test -> NOT not_test .)
    BOOL_TRUE       reduce using rule 62 (not_test -> NOT not_test .)
    BOOL_FALSE      reduce using rule 62 (not_test -> NOT not_test .)
    NONE            reduce using rule 62 (not_test -> NOT not_test .)
    $end            reduce using rule 62 (not_test -> NOT not_test .)
    ELIF            reduce using rule 62 (not_test -> NOT not_test .)
    ELSE            reduce using rule 62 (not_test -> NOT not_test .)
    RPAREN          reduce using rule 62 (not_test -> NOT not_test .)


state 72

    (64) comparison -> expression comphelper .

    AND             reduce using rule 64 (comparison -> expression comphelper .)
    OR              reduce using rule 64 (comparison -> expression comphelper .)
    ASSIGN          reduce using rule 64 (comparison -> expression comphelper .)
    PLUS_ASSIGN     reduce using rule 64 (comparison -> expression comphelper .)
    MINUS_ASSIGN    reduce using rule 64 (comparison -> expression comphelper .)
    TIMES_ASSIGN    reduce using rule 64 (comparison -> expression comphelper .)
    DIVIDE_ASSIGN   reduce using rule 64 (comparison -> expression comphelper .)
    ASSIGN_MODULE   reduce using rule 64 (comparison -> expression comphelper .)
    THEN            reduce using rule 64 (comparison -> expression comphelper .)
    NEWLINE         reduce using rule 64 (comparison -> expression comphelper .)
    IF              reduce using rule 64 (comparison -> expression comphelper .)
    FOR             reduce using rule 64 (comparison -> expression comphelper .)
    BREAK           reduce using rule 64 (comparison -> expression comphelper .)
    PRINT           reduce using rule 64 (comparison -> expression comphelper .)
    CDEF            reduce using rule 64 (comparison -> expression comphelper .)
    NOT             reduce using rule 64 (comparison -> expression comphelper .)
    LPAREN          reduce using rule 64 (comparison -> expression comphelper .)
    ID              reduce using rule 64 (comparison -> expression comphelper .)
    NUMBER          reduce using rule 64 (comparison -> expression comphelper .)
    STRING          reduce using rule 64 (comparison -> expression comphelper .)
    BOOL_TRUE       reduce using rule 64 (comparison -> expression comphelper .)
    BOOL_FALSE      reduce using rule 64 (comparison -> expression comphelper .)
    NONE            reduce using rule 64 (comparison -> expression comphelper .)
    $end            reduce using rule 64 (comparison -> expression comphelper .)
    ELIF            reduce using rule 64 (comparison -> expression comphelper .)
    ELSE            reduce using rule 64 (comparison -> expression comphelper .)
    RPAREN          reduce using rule 64 (comparison -> expression comphelper .)


state 73

    (65) comphelper -> comp_op . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    expression                     shift and go to state 117
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 74

    (66) comphelper -> empty .

    AND             reduce using rule 66 (comphelper -> empty .)
    OR              reduce using rule 66 (comphelper -> empty .)
    ASSIGN          reduce using rule 66 (comphelper -> empty .)
    PLUS_ASSIGN     reduce using rule 66 (comphelper -> empty .)
    MINUS_ASSIGN    reduce using rule 66 (comphelper -> empty .)
    TIMES_ASSIGN    reduce using rule 66 (comphelper -> empty .)
    DIVIDE_ASSIGN   reduce using rule 66 (comphelper -> empty .)
    ASSIGN_MODULE   reduce using rule 66 (comphelper -> empty .)
    THEN            reduce using rule 66 (comphelper -> empty .)
    NEWLINE         reduce using rule 66 (comphelper -> empty .)
    IF              reduce using rule 66 (comphelper -> empty .)
    FOR             reduce using rule 66 (comphelper -> empty .)
    BREAK           reduce using rule 66 (comphelper -> empty .)
    PRINT           reduce using rule 66 (comphelper -> empty .)
    CDEF            reduce using rule 66 (comphelper -> empty .)
    NOT             reduce using rule 66 (comphelper -> empty .)
    LPAREN          reduce using rule 66 (comphelper -> empty .)
    ID              reduce using rule 66 (comphelper -> empty .)
    NUMBER          reduce using rule 66 (comphelper -> empty .)
    STRING          reduce using rule 66 (comphelper -> empty .)
    BOOL_TRUE       reduce using rule 66 (comphelper -> empty .)
    BOOL_FALSE      reduce using rule 66 (comphelper -> empty .)
    NONE            reduce using rule 66 (comphelper -> empty .)
    $end            reduce using rule 66 (comphelper -> empty .)
    ELIF            reduce using rule 66 (comphelper -> empty .)
    ELSE            reduce using rule 66 (comphelper -> empty .)
    RPAREN          reduce using rule 66 (comphelper -> empty .)


state 75

    (67) comp_op -> LESS_THAN .

    LPAREN          reduce using rule 67 (comp_op -> LESS_THAN .)
    ID              reduce using rule 67 (comp_op -> LESS_THAN .)
    NUMBER          reduce using rule 67 (comp_op -> LESS_THAN .)
    STRING          reduce using rule 67 (comp_op -> LESS_THAN .)
    BOOL_TRUE       reduce using rule 67 (comp_op -> LESS_THAN .)
    BOOL_FALSE      reduce using rule 67 (comp_op -> LESS_THAN .)
    NONE            reduce using rule 67 (comp_op -> LESS_THAN .)


state 76

    (68) comp_op -> MORE_THAN .

    LPAREN          reduce using rule 68 (comp_op -> MORE_THAN .)
    ID              reduce using rule 68 (comp_op -> MORE_THAN .)
    NUMBER          reduce using rule 68 (comp_op -> MORE_THAN .)
    STRING          reduce using rule 68 (comp_op -> MORE_THAN .)
    BOOL_TRUE       reduce using rule 68 (comp_op -> MORE_THAN .)
    BOOL_FALSE      reduce using rule 68 (comp_op -> MORE_THAN .)
    NONE            reduce using rule 68 (comp_op -> MORE_THAN .)


state 77

    (69) comp_op -> EQUALS .

    LPAREN          reduce using rule 69 (comp_op -> EQUALS .)
    ID              reduce using rule 69 (comp_op -> EQUALS .)
    NUMBER          reduce using rule 69 (comp_op -> EQUALS .)
    STRING          reduce using rule 69 (comp_op -> EQUALS .)
    BOOL_TRUE       reduce using rule 69 (comp_op -> EQUALS .)
    BOOL_FALSE      reduce using rule 69 (comp_op -> EQUALS .)
    NONE            reduce using rule 69 (comp_op -> EQUALS .)


state 78

    (70) comp_op -> MORE_EQUAL .

    LPAREN          reduce using rule 70 (comp_op -> MORE_EQUAL .)
    ID              reduce using rule 70 (comp_op -> MORE_EQUAL .)
    NUMBER          reduce using rule 70 (comp_op -> MORE_EQUAL .)
    STRING          reduce using rule 70 (comp_op -> MORE_EQUAL .)
    BOOL_TRUE       reduce using rule 70 (comp_op -> MORE_EQUAL .)
    BOOL_FALSE      reduce using rule 70 (comp_op -> MORE_EQUAL .)
    NONE            reduce using rule 70 (comp_op -> MORE_EQUAL .)


state 79

    (71) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 71 (comp_op -> LESS_EQUAL .)
    ID              reduce using rule 71 (comp_op -> LESS_EQUAL .)
    NUMBER          reduce using rule 71 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 71 (comp_op -> LESS_EQUAL .)
    BOOL_TRUE       reduce using rule 71 (comp_op -> LESS_EQUAL .)
    BOOL_FALSE      reduce using rule 71 (comp_op -> LESS_EQUAL .)
    NONE            reduce using rule 71 (comp_op -> LESS_EQUAL .)


state 80

    (72) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 72 (comp_op -> NOT_EQUAL .)
    ID              reduce using rule 72 (comp_op -> NOT_EQUAL .)
    NUMBER          reduce using rule 72 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 72 (comp_op -> NOT_EQUAL .)
    BOOL_TRUE       reduce using rule 72 (comp_op -> NOT_EQUAL .)
    BOOL_FALSE      reduce using rule 72 (comp_op -> NOT_EQUAL .)
    NONE            reduce using rule 72 (comp_op -> NOT_EQUAL .)


state 81

    (73) comp_op -> IN .

    LPAREN          reduce using rule 73 (comp_op -> IN .)
    ID              reduce using rule 73 (comp_op -> IN .)
    NUMBER          reduce using rule 73 (comp_op -> IN .)
    STRING          reduce using rule 73 (comp_op -> IN .)
    BOOL_TRUE       reduce using rule 73 (comp_op -> IN .)
    BOOL_FALSE      reduce using rule 73 (comp_op -> IN .)
    NONE            reduce using rule 73 (comp_op -> IN .)


state 82

    (74) comp_op -> NOT_IN .

    LPAREN          reduce using rule 74 (comp_op -> NOT_IN .)
    ID              reduce using rule 74 (comp_op -> NOT_IN .)
    NUMBER          reduce using rule 74 (comp_op -> NOT_IN .)
    STRING          reduce using rule 74 (comp_op -> NOT_IN .)
    BOOL_TRUE       reduce using rule 74 (comp_op -> NOT_IN .)
    BOOL_FALSE      reduce using rule 74 (comp_op -> NOT_IN .)
    NONE            reduce using rule 74 (comp_op -> NOT_IN .)


state 83

    (75) comp_op -> IS .

    LPAREN          reduce using rule 75 (comp_op -> IS .)
    ID              reduce using rule 75 (comp_op -> IS .)
    NUMBER          reduce using rule 75 (comp_op -> IS .)
    STRING          reduce using rule 75 (comp_op -> IS .)
    BOOL_TRUE       reduce using rule 75 (comp_op -> IS .)
    BOOL_FALSE      reduce using rule 75 (comp_op -> IS .)
    NONE            reduce using rule 75 (comp_op -> IS .)


state 84

    (76) comp_op -> IS_NOT .

    LPAREN          reduce using rule 76 (comp_op -> IS_NOT .)
    ID              reduce using rule 76 (comp_op -> IS_NOT .)
    NUMBER          reduce using rule 76 (comp_op -> IS_NOT .)
    STRING          reduce using rule 76 (comp_op -> IS_NOT .)
    BOOL_TRUE       reduce using rule 76 (comp_op -> IS_NOT .)
    BOOL_FALSE      reduce using rule 76 (comp_op -> IS_NOT .)
    NONE            reduce using rule 76 (comp_op -> IS_NOT .)


state 85

    (78) arith_expr -> term PLUS . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    term                           shift and go to state 31
    arith_expr                     shift and go to state 118
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 86

    (79) arith_expr -> term MINUS . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    term                           shift and go to state 31
    arith_expr                     shift and go to state 119
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 87

    (80) arith_expr -> term empty .

    LESS_THAN       reduce using rule 80 (arith_expr -> term empty .)
    MORE_THAN       reduce using rule 80 (arith_expr -> term empty .)
    EQUALS          reduce using rule 80 (arith_expr -> term empty .)
    MORE_EQUAL      reduce using rule 80 (arith_expr -> term empty .)
    LESS_EQUAL      reduce using rule 80 (arith_expr -> term empty .)
    NOT_EQUAL       reduce using rule 80 (arith_expr -> term empty .)
    IN              reduce using rule 80 (arith_expr -> term empty .)
    NOT_IN          reduce using rule 80 (arith_expr -> term empty .)
    IS              reduce using rule 80 (arith_expr -> term empty .)
    IS_NOT          reduce using rule 80 (arith_expr -> term empty .)
    AND             reduce using rule 80 (arith_expr -> term empty .)
    OR              reduce using rule 80 (arith_expr -> term empty .)
    ASSIGN          reduce using rule 80 (arith_expr -> term empty .)
    PLUS_ASSIGN     reduce using rule 80 (arith_expr -> term empty .)
    MINUS_ASSIGN    reduce using rule 80 (arith_expr -> term empty .)
    TIMES_ASSIGN    reduce using rule 80 (arith_expr -> term empty .)
    DIVIDE_ASSIGN   reduce using rule 80 (arith_expr -> term empty .)
    ASSIGN_MODULE   reduce using rule 80 (arith_expr -> term empty .)
    THEN            reduce using rule 80 (arith_expr -> term empty .)
    NEWLINE         reduce using rule 80 (arith_expr -> term empty .)
    IF              reduce using rule 80 (arith_expr -> term empty .)
    FOR             reduce using rule 80 (arith_expr -> term empty .)
    BREAK           reduce using rule 80 (arith_expr -> term empty .)
    PRINT           reduce using rule 80 (arith_expr -> term empty .)
    CDEF            reduce using rule 80 (arith_expr -> term empty .)
    NOT             reduce using rule 80 (arith_expr -> term empty .)
    LPAREN          reduce using rule 80 (arith_expr -> term empty .)
    ID              reduce using rule 80 (arith_expr -> term empty .)
    NUMBER          reduce using rule 80 (arith_expr -> term empty .)
    STRING          reduce using rule 80 (arith_expr -> term empty .)
    BOOL_TRUE       reduce using rule 80 (arith_expr -> term empty .)
    BOOL_FALSE      reduce using rule 80 (arith_expr -> term empty .)
    NONE            reduce using rule 80 (arith_expr -> term empty .)
    $end            reduce using rule 80 (arith_expr -> term empty .)
    ELIF            reduce using rule 80 (arith_expr -> term empty .)
    ELSE            reduce using rule 80 (arith_expr -> term empty .)
    RPAREN          reduce using rule 80 (arith_expr -> term empty .)


state 88

    (81) term -> factor TIMES . term
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    factor                         shift and go to state 32
    term                           shift and go to state 120
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 89

    (82) term -> factor DIVIDE . term
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    factor                         shift and go to state 32
    term                           shift and go to state 121
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 90

    (83) term -> factor MODULE . term
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    factor                         shift and go to state 32
    term                           shift and go to state 122
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 91

    (84) term -> factor empty .

    PLUS            reduce using rule 84 (term -> factor empty .)
    MINUS           reduce using rule 84 (term -> factor empty .)
    LESS_THAN       reduce using rule 84 (term -> factor empty .)
    MORE_THAN       reduce using rule 84 (term -> factor empty .)
    EQUALS          reduce using rule 84 (term -> factor empty .)
    MORE_EQUAL      reduce using rule 84 (term -> factor empty .)
    LESS_EQUAL      reduce using rule 84 (term -> factor empty .)
    NOT_EQUAL       reduce using rule 84 (term -> factor empty .)
    IN              reduce using rule 84 (term -> factor empty .)
    NOT_IN          reduce using rule 84 (term -> factor empty .)
    IS              reduce using rule 84 (term -> factor empty .)
    IS_NOT          reduce using rule 84 (term -> factor empty .)
    AND             reduce using rule 84 (term -> factor empty .)
    OR              reduce using rule 84 (term -> factor empty .)
    ASSIGN          reduce using rule 84 (term -> factor empty .)
    PLUS_ASSIGN     reduce using rule 84 (term -> factor empty .)
    MINUS_ASSIGN    reduce using rule 84 (term -> factor empty .)
    TIMES_ASSIGN    reduce using rule 84 (term -> factor empty .)
    DIVIDE_ASSIGN   reduce using rule 84 (term -> factor empty .)
    ASSIGN_MODULE   reduce using rule 84 (term -> factor empty .)
    THEN            reduce using rule 84 (term -> factor empty .)
    NEWLINE         reduce using rule 84 (term -> factor empty .)
    IF              reduce using rule 84 (term -> factor empty .)
    FOR             reduce using rule 84 (term -> factor empty .)
    BREAK           reduce using rule 84 (term -> factor empty .)
    PRINT           reduce using rule 84 (term -> factor empty .)
    CDEF            reduce using rule 84 (term -> factor empty .)
    NOT             reduce using rule 84 (term -> factor empty .)
    LPAREN          reduce using rule 84 (term -> factor empty .)
    ID              reduce using rule 84 (term -> factor empty .)
    NUMBER          reduce using rule 84 (term -> factor empty .)
    STRING          reduce using rule 84 (term -> factor empty .)
    BOOL_TRUE       reduce using rule 84 (term -> factor empty .)
    BOOL_FALSE      reduce using rule 84 (term -> factor empty .)
    NONE            reduce using rule 84 (term -> factor empty .)
    $end            reduce using rule 84 (term -> factor empty .)
    ELIF            reduce using rule 84 (term -> factor empty .)
    ELSE            reduce using rule 84 (term -> factor empty .)
    RPAREN          reduce using rule 84 (term -> factor empty .)


state 92

    (87) power -> factor POWER . factor
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    factor                         shift and go to state 123
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 93

    (88) power -> atom_expr empty .

    TIMES           reduce using rule 88 (power -> atom_expr empty .)
    DIVIDE          reduce using rule 88 (power -> atom_expr empty .)
    MODULE          reduce using rule 88 (power -> atom_expr empty .)
    POWER           reduce using rule 88 (power -> atom_expr empty .)
    PLUS            reduce using rule 88 (power -> atom_expr empty .)
    MINUS           reduce using rule 88 (power -> atom_expr empty .)
    LESS_THAN       reduce using rule 88 (power -> atom_expr empty .)
    MORE_THAN       reduce using rule 88 (power -> atom_expr empty .)
    EQUALS          reduce using rule 88 (power -> atom_expr empty .)
    MORE_EQUAL      reduce using rule 88 (power -> atom_expr empty .)
    LESS_EQUAL      reduce using rule 88 (power -> atom_expr empty .)
    NOT_EQUAL       reduce using rule 88 (power -> atom_expr empty .)
    IN              reduce using rule 88 (power -> atom_expr empty .)
    NOT_IN          reduce using rule 88 (power -> atom_expr empty .)
    IS              reduce using rule 88 (power -> atom_expr empty .)
    IS_NOT          reduce using rule 88 (power -> atom_expr empty .)
    AND             reduce using rule 88 (power -> atom_expr empty .)
    OR              reduce using rule 88 (power -> atom_expr empty .)
    ASSIGN          reduce using rule 88 (power -> atom_expr empty .)
    PLUS_ASSIGN     reduce using rule 88 (power -> atom_expr empty .)
    MINUS_ASSIGN    reduce using rule 88 (power -> atom_expr empty .)
    TIMES_ASSIGN    reduce using rule 88 (power -> atom_expr empty .)
    DIVIDE_ASSIGN   reduce using rule 88 (power -> atom_expr empty .)
    ASSIGN_MODULE   reduce using rule 88 (power -> atom_expr empty .)
    THEN            reduce using rule 88 (power -> atom_expr empty .)
    NEWLINE         reduce using rule 88 (power -> atom_expr empty .)
    IF              reduce using rule 88 (power -> atom_expr empty .)
    FOR             reduce using rule 88 (power -> atom_expr empty .)
    BREAK           reduce using rule 88 (power -> atom_expr empty .)
    PRINT           reduce using rule 88 (power -> atom_expr empty .)
    CDEF            reduce using rule 88 (power -> atom_expr empty .)
    NOT             reduce using rule 88 (power -> atom_expr empty .)
    LPAREN          reduce using rule 88 (power -> atom_expr empty .)
    ID              reduce using rule 88 (power -> atom_expr empty .)
    NUMBER          reduce using rule 88 (power -> atom_expr empty .)
    STRING          reduce using rule 88 (power -> atom_expr empty .)
    BOOL_TRUE       reduce using rule 88 (power -> atom_expr empty .)
    BOOL_FALSE      reduce using rule 88 (power -> atom_expr empty .)
    NONE            reduce using rule 88 (power -> atom_expr empty .)
    $end            reduce using rule 88 (power -> atom_expr empty .)
    ELIF            reduce using rule 88 (power -> atom_expr empty .)
    ELSE            reduce using rule 88 (power -> atom_expr empty .)
    RPAREN          reduce using rule 88 (power -> atom_expr empty .)


state 94

    (7) simplehelper -> NEWLINE small_stmt . simplehelper
    (7) simplehelper -> . NEWLINE small_stmt simplehelper
    (8) simplehelper -> . empty
    (96) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 45
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)

  ! NEWLINE         [ reduce using rule 96 (empty -> .) ]

    simplehelper                   shift and go to state 124
    empty                          shift and go to state 46

state 95

    (34) if_stmnt -> IF test THEN . suite NEWLINE
    (36) compound_if -> IF test THEN . itersuite elif_stmnt else_stmnt
    (37) compound_if -> IF test THEN . itersuite if_stmnt else_stmnt
    (53) suite -> . simple_stmt
    (54) suite -> . NEWLINE INDENT stmt
    (38) itersuite -> . suite itersuite
    (39) itersuite -> . suite elif_stmnt
    (6) simple_stmt -> . small_stmt simplehelper
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NEWLINE         shift and go to state 126
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 13
    suite                          shift and go to state 125
    itersuite                      shift and go to state 127
    simple_stmt                    shift and go to state 128
    small_stmt                     shift and go to state 5
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 96

    (24) annassign -> test ASSIGN test .

    NEWLINE         reduce using rule 24 (annassign -> test ASSIGN test .)
    IF              reduce using rule 24 (annassign -> test ASSIGN test .)
    FOR             reduce using rule 24 (annassign -> test ASSIGN test .)
    BREAK           reduce using rule 24 (annassign -> test ASSIGN test .)
    PRINT           reduce using rule 24 (annassign -> test ASSIGN test .)
    CDEF            reduce using rule 24 (annassign -> test ASSIGN test .)
    NOT             reduce using rule 24 (annassign -> test ASSIGN test .)
    LPAREN          reduce using rule 24 (annassign -> test ASSIGN test .)
    ID              reduce using rule 24 (annassign -> test ASSIGN test .)
    NUMBER          reduce using rule 24 (annassign -> test ASSIGN test .)
    STRING          reduce using rule 24 (annassign -> test ASSIGN test .)
    BOOL_TRUE       reduce using rule 24 (annassign -> test ASSIGN test .)
    BOOL_FALSE      reduce using rule 24 (annassign -> test ASSIGN test .)
    NONE            reduce using rule 24 (annassign -> test ASSIGN test .)
    $end            reduce using rule 24 (annassign -> test ASSIGN test .)
    ELIF            reduce using rule 24 (annassign -> test ASSIGN test .)
    ELSE            reduce using rule 24 (annassign -> test ASSIGN test .)


state 97

    (13) input_stmt -> test ASSIGN INPUT . LPAREN STRING RPAREN

    LPAREN          shift and go to state 129


state 98

    (25) augassign -> test PLUS_ASSIGN test .

    NEWLINE         reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    IF              reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    FOR             reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    BREAK           reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    PRINT           reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    CDEF            reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    NOT             reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    LPAREN          reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    ID              reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    NUMBER          reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    STRING          reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    BOOL_TRUE       reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    BOOL_FALSE      reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    NONE            reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    $end            reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    ELIF            reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)
    ELSE            reduce using rule 25 (augassign -> test PLUS_ASSIGN test .)


state 99

    (26) augassign -> test MINUS_ASSIGN test .

    NEWLINE         reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    IF              reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    FOR             reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    BREAK           reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    PRINT           reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    CDEF            reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    NOT             reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    LPAREN          reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    ID              reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    NUMBER          reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    STRING          reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    BOOL_TRUE       reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    BOOL_FALSE      reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    NONE            reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    $end            reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    ELIF            reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)
    ELSE            reduce using rule 26 (augassign -> test MINUS_ASSIGN test .)


state 100

    (27) augassign -> test TIMES_ASSIGN test .

    NEWLINE         reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    IF              reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    FOR             reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    BREAK           reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    PRINT           reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    CDEF            reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    NOT             reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    LPAREN          reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    ID              reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    NUMBER          reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    STRING          reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    BOOL_TRUE       reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    BOOL_FALSE      reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    NONE            reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    $end            reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    ELIF            reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)
    ELSE            reduce using rule 27 (augassign -> test TIMES_ASSIGN test .)


state 101

    (28) augassign -> test DIVIDE_ASSIGN test .

    NEWLINE         reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    IF              reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    FOR             reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    BREAK           reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    PRINT           reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    CDEF            reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    NOT             reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    LPAREN          reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    ID              reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    NUMBER          reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    STRING          reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    BOOL_TRUE       reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    BOOL_FALSE      reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    NONE            reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    $end            reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    ELIF            reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)
    ELSE            reduce using rule 28 (augassign -> test DIVIDE_ASSIGN test .)


state 102

    (29) augassign -> test ASSIGN_MODULE test .

    NEWLINE         reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    IF              reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    FOR             reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    BREAK           reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    PRINT           reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    CDEF            reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    NOT             reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    LPAREN          reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    ID              reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    NUMBER          reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    STRING          reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    BOOL_TRUE       reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    BOOL_FALSE      reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    NONE            reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    $end            reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    ELIF            reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)
    ELSE            reduce using rule 29 (augassign -> test ASSIGN_MODULE test .)


state 103

    (45) for_stmt -> FOR exprlist IN . testlist THEN stmt
    (46) for_stmt -> FOR exprlist IN . RANGE THEN stmt
    (50) testlist -> . test testlisthelper
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    RANGE           shift and go to state 131
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    testlist                       shift and go to state 130
    test                           shift and go to state 132
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 104

    (47) exprlist -> expression exprlisthelper .

    IN              reduce using rule 47 (exprlist -> expression exprlisthelper .)


state 105

    (48) exprlisthelper -> NEWLINE . expression exprlisthelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    expression                     shift and go to state 133
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 106

    (49) exprlisthelper -> empty .

    IN              reduce using rule 49 (exprlisthelper -> empty .)
    THEN            reduce using rule 49 (exprlisthelper -> empty .)


state 107

    (12) print_stmt -> PRINT LPAREN test . RPAREN

    RPAREN          shift and go to state 134


state 108

    (85) factor -> LPAREN MINUS factor . RPAREN
    (87) power -> factor . POWER factor

    RPAREN          shift and go to state 135
    POWER           shift and go to state 92


state 109

    (18) vartypes -> INT test . ASSIGN test

    ASSIGN          shift and go to state 136


state 110

    (19) vartypes -> DOUBLE test . ASSIGN test

    ASSIGN          shift and go to state 137


state 111

    (20) vartypes -> SHORT test . ASSIGN test

    ASSIGN          shift and go to state 138


state 112

    (21) vartypes -> LONG test . ASSIGN test

    ASSIGN          shift and go to state 139


state 113

    (22) vartypes -> CHAR test . ASSIGN test

    ASSIGN          shift and go to state 140


state 114

    (23) vartypes -> FLOAT test . ASSIGN test

    ASSIGN          shift and go to state 141


state 115

    (57) or_comp -> OR and_test . or_comp
    (57) or_comp -> . OR and_test or_comp
    (58) or_comp -> . empty
    (96) empty -> .

    OR              shift and go to state 66
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    or_comp                        shift and go to state 142
    empty                          shift and go to state 67

state 116

    (60) and_comp -> AND not_test . and_comp
    (60) and_comp -> . AND not_test and_comp
    (61) and_comp -> . empty
    (96) empty -> .

    AND             shift and go to state 69
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    and_comp                       shift and go to state 143
    empty                          shift and go to state 70

state 117

    (65) comphelper -> comp_op expression . comphelper
    (65) comphelper -> . comp_op expression comphelper
    (66) comphelper -> . empty
    (67) comp_op -> . LESS_THAN
    (68) comp_op -> . MORE_THAN
    (69) comp_op -> . EQUALS
    (70) comp_op -> . MORE_EQUAL
    (71) comp_op -> . LESS_EQUAL
    (72) comp_op -> . NOT_EQUAL
    (73) comp_op -> . IN
    (74) comp_op -> . NOT_IN
    (75) comp_op -> . IS
    (76) comp_op -> . IS_NOT
    (96) empty -> .

    LESS_THAN       shift and go to state 75
    MORE_THAN       shift and go to state 76
    EQUALS          shift and go to state 77
    MORE_EQUAL      shift and go to state 78
    LESS_EQUAL      shift and go to state 79
    NOT_EQUAL       shift and go to state 80
    IN              shift and go to state 81
    NOT_IN          shift and go to state 82
    IS              shift and go to state 83
    IS_NOT          shift and go to state 84
    AND             reduce using rule 96 (empty -> .)
    OR              reduce using rule 96 (empty -> .)
    ASSIGN          reduce using rule 96 (empty -> .)
    PLUS_ASSIGN     reduce using rule 96 (empty -> .)
    MINUS_ASSIGN    reduce using rule 96 (empty -> .)
    TIMES_ASSIGN    reduce using rule 96 (empty -> .)
    DIVIDE_ASSIGN   reduce using rule 96 (empty -> .)
    ASSIGN_MODULE   reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)
    NEWLINE         reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    ELSE            reduce using rule 96 (empty -> .)
    RPAREN          reduce using rule 96 (empty -> .)

    comp_op                        shift and go to state 73
    comphelper                     shift and go to state 144
    empty                          shift and go to state 74

state 118

    (78) arith_expr -> term PLUS arith_expr .

    LESS_THAN       reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    MORE_THAN       reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    EQUALS          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    MORE_EQUAL      reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    LESS_EQUAL      reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    NOT_EQUAL       reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    IN              reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    NOT_IN          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    IS              reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    IS_NOT          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    AND             reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    OR              reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    ASSIGN          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    PLUS_ASSIGN     reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    MINUS_ASSIGN    reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    TIMES_ASSIGN    reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    DIVIDE_ASSIGN   reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    ASSIGN_MODULE   reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    THEN            reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    NEWLINE         reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    IF              reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    FOR             reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    BREAK           reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    PRINT           reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    CDEF            reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    NOT             reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    LPAREN          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    ID              reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    NUMBER          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    STRING          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    BOOL_TRUE       reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    BOOL_FALSE      reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    NONE            reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    $end            reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    ELIF            reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    ELSE            reduce using rule 78 (arith_expr -> term PLUS arith_expr .)
    RPAREN          reduce using rule 78 (arith_expr -> term PLUS arith_expr .)


state 119

    (79) arith_expr -> term MINUS arith_expr .

    LESS_THAN       reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    MORE_THAN       reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    EQUALS          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    MORE_EQUAL      reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    LESS_EQUAL      reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    NOT_EQUAL       reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    IN              reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    NOT_IN          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    IS              reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    IS_NOT          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    AND             reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    OR              reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    ASSIGN          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    PLUS_ASSIGN     reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    MINUS_ASSIGN    reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    TIMES_ASSIGN    reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    DIVIDE_ASSIGN   reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    ASSIGN_MODULE   reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    THEN            reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    NEWLINE         reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    IF              reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    FOR             reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    BREAK           reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    PRINT           reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    CDEF            reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    NOT             reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    LPAREN          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    ID              reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    NUMBER          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    STRING          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    BOOL_TRUE       reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    BOOL_FALSE      reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    NONE            reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    $end            reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    ELIF            reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    ELSE            reduce using rule 79 (arith_expr -> term MINUS arith_expr .)
    RPAREN          reduce using rule 79 (arith_expr -> term MINUS arith_expr .)


state 120

    (81) term -> factor TIMES term .

    PLUS            reduce using rule 81 (term -> factor TIMES term .)
    MINUS           reduce using rule 81 (term -> factor TIMES term .)
    LESS_THAN       reduce using rule 81 (term -> factor TIMES term .)
    MORE_THAN       reduce using rule 81 (term -> factor TIMES term .)
    EQUALS          reduce using rule 81 (term -> factor TIMES term .)
    MORE_EQUAL      reduce using rule 81 (term -> factor TIMES term .)
    LESS_EQUAL      reduce using rule 81 (term -> factor TIMES term .)
    NOT_EQUAL       reduce using rule 81 (term -> factor TIMES term .)
    IN              reduce using rule 81 (term -> factor TIMES term .)
    NOT_IN          reduce using rule 81 (term -> factor TIMES term .)
    IS              reduce using rule 81 (term -> factor TIMES term .)
    IS_NOT          reduce using rule 81 (term -> factor TIMES term .)
    AND             reduce using rule 81 (term -> factor TIMES term .)
    OR              reduce using rule 81 (term -> factor TIMES term .)
    ASSIGN          reduce using rule 81 (term -> factor TIMES term .)
    PLUS_ASSIGN     reduce using rule 81 (term -> factor TIMES term .)
    MINUS_ASSIGN    reduce using rule 81 (term -> factor TIMES term .)
    TIMES_ASSIGN    reduce using rule 81 (term -> factor TIMES term .)
    DIVIDE_ASSIGN   reduce using rule 81 (term -> factor TIMES term .)
    ASSIGN_MODULE   reduce using rule 81 (term -> factor TIMES term .)
    THEN            reduce using rule 81 (term -> factor TIMES term .)
    NEWLINE         reduce using rule 81 (term -> factor TIMES term .)
    IF              reduce using rule 81 (term -> factor TIMES term .)
    FOR             reduce using rule 81 (term -> factor TIMES term .)
    BREAK           reduce using rule 81 (term -> factor TIMES term .)
    PRINT           reduce using rule 81 (term -> factor TIMES term .)
    CDEF            reduce using rule 81 (term -> factor TIMES term .)
    NOT             reduce using rule 81 (term -> factor TIMES term .)
    LPAREN          reduce using rule 81 (term -> factor TIMES term .)
    ID              reduce using rule 81 (term -> factor TIMES term .)
    NUMBER          reduce using rule 81 (term -> factor TIMES term .)
    STRING          reduce using rule 81 (term -> factor TIMES term .)
    BOOL_TRUE       reduce using rule 81 (term -> factor TIMES term .)
    BOOL_FALSE      reduce using rule 81 (term -> factor TIMES term .)
    NONE            reduce using rule 81 (term -> factor TIMES term .)
    $end            reduce using rule 81 (term -> factor TIMES term .)
    ELIF            reduce using rule 81 (term -> factor TIMES term .)
    ELSE            reduce using rule 81 (term -> factor TIMES term .)
    RPAREN          reduce using rule 81 (term -> factor TIMES term .)


state 121

    (82) term -> factor DIVIDE term .

    PLUS            reduce using rule 82 (term -> factor DIVIDE term .)
    MINUS           reduce using rule 82 (term -> factor DIVIDE term .)
    LESS_THAN       reduce using rule 82 (term -> factor DIVIDE term .)
    MORE_THAN       reduce using rule 82 (term -> factor DIVIDE term .)
    EQUALS          reduce using rule 82 (term -> factor DIVIDE term .)
    MORE_EQUAL      reduce using rule 82 (term -> factor DIVIDE term .)
    LESS_EQUAL      reduce using rule 82 (term -> factor DIVIDE term .)
    NOT_EQUAL       reduce using rule 82 (term -> factor DIVIDE term .)
    IN              reduce using rule 82 (term -> factor DIVIDE term .)
    NOT_IN          reduce using rule 82 (term -> factor DIVIDE term .)
    IS              reduce using rule 82 (term -> factor DIVIDE term .)
    IS_NOT          reduce using rule 82 (term -> factor DIVIDE term .)
    AND             reduce using rule 82 (term -> factor DIVIDE term .)
    OR              reduce using rule 82 (term -> factor DIVIDE term .)
    ASSIGN          reduce using rule 82 (term -> factor DIVIDE term .)
    PLUS_ASSIGN     reduce using rule 82 (term -> factor DIVIDE term .)
    MINUS_ASSIGN    reduce using rule 82 (term -> factor DIVIDE term .)
    TIMES_ASSIGN    reduce using rule 82 (term -> factor DIVIDE term .)
    DIVIDE_ASSIGN   reduce using rule 82 (term -> factor DIVIDE term .)
    ASSIGN_MODULE   reduce using rule 82 (term -> factor DIVIDE term .)
    THEN            reduce using rule 82 (term -> factor DIVIDE term .)
    NEWLINE         reduce using rule 82 (term -> factor DIVIDE term .)
    IF              reduce using rule 82 (term -> factor DIVIDE term .)
    FOR             reduce using rule 82 (term -> factor DIVIDE term .)
    BREAK           reduce using rule 82 (term -> factor DIVIDE term .)
    PRINT           reduce using rule 82 (term -> factor DIVIDE term .)
    CDEF            reduce using rule 82 (term -> factor DIVIDE term .)
    NOT             reduce using rule 82 (term -> factor DIVIDE term .)
    LPAREN          reduce using rule 82 (term -> factor DIVIDE term .)
    ID              reduce using rule 82 (term -> factor DIVIDE term .)
    NUMBER          reduce using rule 82 (term -> factor DIVIDE term .)
    STRING          reduce using rule 82 (term -> factor DIVIDE term .)
    BOOL_TRUE       reduce using rule 82 (term -> factor DIVIDE term .)
    BOOL_FALSE      reduce using rule 82 (term -> factor DIVIDE term .)
    NONE            reduce using rule 82 (term -> factor DIVIDE term .)
    $end            reduce using rule 82 (term -> factor DIVIDE term .)
    ELIF            reduce using rule 82 (term -> factor DIVIDE term .)
    ELSE            reduce using rule 82 (term -> factor DIVIDE term .)
    RPAREN          reduce using rule 82 (term -> factor DIVIDE term .)


state 122

    (83) term -> factor MODULE term .

    PLUS            reduce using rule 83 (term -> factor MODULE term .)
    MINUS           reduce using rule 83 (term -> factor MODULE term .)
    LESS_THAN       reduce using rule 83 (term -> factor MODULE term .)
    MORE_THAN       reduce using rule 83 (term -> factor MODULE term .)
    EQUALS          reduce using rule 83 (term -> factor MODULE term .)
    MORE_EQUAL      reduce using rule 83 (term -> factor MODULE term .)
    LESS_EQUAL      reduce using rule 83 (term -> factor MODULE term .)
    NOT_EQUAL       reduce using rule 83 (term -> factor MODULE term .)
    IN              reduce using rule 83 (term -> factor MODULE term .)
    NOT_IN          reduce using rule 83 (term -> factor MODULE term .)
    IS              reduce using rule 83 (term -> factor MODULE term .)
    IS_NOT          reduce using rule 83 (term -> factor MODULE term .)
    AND             reduce using rule 83 (term -> factor MODULE term .)
    OR              reduce using rule 83 (term -> factor MODULE term .)
    ASSIGN          reduce using rule 83 (term -> factor MODULE term .)
    PLUS_ASSIGN     reduce using rule 83 (term -> factor MODULE term .)
    MINUS_ASSIGN    reduce using rule 83 (term -> factor MODULE term .)
    TIMES_ASSIGN    reduce using rule 83 (term -> factor MODULE term .)
    DIVIDE_ASSIGN   reduce using rule 83 (term -> factor MODULE term .)
    ASSIGN_MODULE   reduce using rule 83 (term -> factor MODULE term .)
    THEN            reduce using rule 83 (term -> factor MODULE term .)
    NEWLINE         reduce using rule 83 (term -> factor MODULE term .)
    IF              reduce using rule 83 (term -> factor MODULE term .)
    FOR             reduce using rule 83 (term -> factor MODULE term .)
    BREAK           reduce using rule 83 (term -> factor MODULE term .)
    PRINT           reduce using rule 83 (term -> factor MODULE term .)
    CDEF            reduce using rule 83 (term -> factor MODULE term .)
    NOT             reduce using rule 83 (term -> factor MODULE term .)
    LPAREN          reduce using rule 83 (term -> factor MODULE term .)
    ID              reduce using rule 83 (term -> factor MODULE term .)
    NUMBER          reduce using rule 83 (term -> factor MODULE term .)
    STRING          reduce using rule 83 (term -> factor MODULE term .)
    BOOL_TRUE       reduce using rule 83 (term -> factor MODULE term .)
    BOOL_FALSE      reduce using rule 83 (term -> factor MODULE term .)
    NONE            reduce using rule 83 (term -> factor MODULE term .)
    $end            reduce using rule 83 (term -> factor MODULE term .)
    ELIF            reduce using rule 83 (term -> factor MODULE term .)
    ELSE            reduce using rule 83 (term -> factor MODULE term .)
    RPAREN          reduce using rule 83 (term -> factor MODULE term .)


state 123

    (87) power -> factor POWER factor .
    (87) power -> factor . POWER factor

    TIMES           reduce using rule 87 (power -> factor POWER factor .)
    DIVIDE          reduce using rule 87 (power -> factor POWER factor .)
    MODULE          reduce using rule 87 (power -> factor POWER factor .)
    POWER           reduce using rule 87 (power -> factor POWER factor .)
    PLUS            reduce using rule 87 (power -> factor POWER factor .)
    MINUS           reduce using rule 87 (power -> factor POWER factor .)
    LESS_THAN       reduce using rule 87 (power -> factor POWER factor .)
    MORE_THAN       reduce using rule 87 (power -> factor POWER factor .)
    EQUALS          reduce using rule 87 (power -> factor POWER factor .)
    MORE_EQUAL      reduce using rule 87 (power -> factor POWER factor .)
    LESS_EQUAL      reduce using rule 87 (power -> factor POWER factor .)
    NOT_EQUAL       reduce using rule 87 (power -> factor POWER factor .)
    IN              reduce using rule 87 (power -> factor POWER factor .)
    NOT_IN          reduce using rule 87 (power -> factor POWER factor .)
    IS              reduce using rule 87 (power -> factor POWER factor .)
    IS_NOT          reduce using rule 87 (power -> factor POWER factor .)
    AND             reduce using rule 87 (power -> factor POWER factor .)
    OR              reduce using rule 87 (power -> factor POWER factor .)
    ASSIGN          reduce using rule 87 (power -> factor POWER factor .)
    PLUS_ASSIGN     reduce using rule 87 (power -> factor POWER factor .)
    MINUS_ASSIGN    reduce using rule 87 (power -> factor POWER factor .)
    TIMES_ASSIGN    reduce using rule 87 (power -> factor POWER factor .)
    DIVIDE_ASSIGN   reduce using rule 87 (power -> factor POWER factor .)
    ASSIGN_MODULE   reduce using rule 87 (power -> factor POWER factor .)
    THEN            reduce using rule 87 (power -> factor POWER factor .)
    NEWLINE         reduce using rule 87 (power -> factor POWER factor .)
    IF              reduce using rule 87 (power -> factor POWER factor .)
    FOR             reduce using rule 87 (power -> factor POWER factor .)
    BREAK           reduce using rule 87 (power -> factor POWER factor .)
    PRINT           reduce using rule 87 (power -> factor POWER factor .)
    CDEF            reduce using rule 87 (power -> factor POWER factor .)
    NOT             reduce using rule 87 (power -> factor POWER factor .)
    LPAREN          reduce using rule 87 (power -> factor POWER factor .)
    ID              reduce using rule 87 (power -> factor POWER factor .)
    NUMBER          reduce using rule 87 (power -> factor POWER factor .)
    STRING          reduce using rule 87 (power -> factor POWER factor .)
    BOOL_TRUE       reduce using rule 87 (power -> factor POWER factor .)
    BOOL_FALSE      reduce using rule 87 (power -> factor POWER factor .)
    NONE            reduce using rule 87 (power -> factor POWER factor .)
    $end            reduce using rule 87 (power -> factor POWER factor .)
    ELIF            reduce using rule 87 (power -> factor POWER factor .)
    ELSE            reduce using rule 87 (power -> factor POWER factor .)
    RPAREN          reduce using rule 87 (power -> factor POWER factor .)

  ! POWER           [ shift and go to state 92 ]


state 124

    (7) simplehelper -> NEWLINE small_stmt simplehelper .

    IF              reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    FOR             reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    BREAK           reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    PRINT           reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    CDEF            reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    NOT             reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    LPAREN          reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    ID              reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    NUMBER          reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    STRING          reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    BOOL_TRUE       reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    BOOL_FALSE      reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    NONE            reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    $end            reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    NEWLINE         reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    ELIF            reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)
    ELSE            reduce using rule 7 (simplehelper -> NEWLINE small_stmt simplehelper .)


state 125

    (34) if_stmnt -> IF test THEN suite . NEWLINE
    (38) itersuite -> suite . itersuite
    (39) itersuite -> suite . elif_stmnt
    (38) itersuite -> . suite itersuite
    (39) itersuite -> . suite elif_stmnt
    (43) elif_stmnt -> . ELIF test THEN suite elif_stmnt
    (44) elif_stmnt -> . else_stmnt
    (53) suite -> . simple_stmt
    (54) suite -> . NEWLINE INDENT stmt
    (40) else_stmnt -> . ELSE THEN suite
    (41) else_stmnt -> . ELSE THEN if_stmnt
    (42) else_stmnt -> . empty
    (6) simple_stmt -> . small_stmt simplehelper
    (96) empty -> .
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ELIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CDEF resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL_TRUE resolved as shift
  ! shift/reduce conflict for BOOL_FALSE resolved as shift
  ! shift/reduce conflict for NONE resolved as shift
    NEWLINE         shift and go to state 146
    ELIF            shift and go to state 149
    ELSE            shift and go to state 151
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

  ! NEWLINE         [ reduce using rule 96 (empty -> .) ]
  ! ELIF            [ reduce using rule 96 (empty -> .) ]
  ! ELSE            [ reduce using rule 96 (empty -> .) ]
  ! PRINT           [ reduce using rule 96 (empty -> .) ]
  ! CDEF            [ reduce using rule 96 (empty -> .) ]
  ! NOT             [ reduce using rule 96 (empty -> .) ]
  ! LPAREN          [ reduce using rule 96 (empty -> .) ]
  ! ID              [ reduce using rule 96 (empty -> .) ]
  ! NUMBER          [ reduce using rule 96 (empty -> .) ]
  ! STRING          [ reduce using rule 96 (empty -> .) ]
  ! BOOL_TRUE       [ reduce using rule 96 (empty -> .) ]
  ! BOOL_FALSE      [ reduce using rule 96 (empty -> .) ]
  ! NONE            [ reduce using rule 96 (empty -> .) ]

    test                           shift and go to state 13
    suite                          shift and go to state 145
    itersuite                      shift and go to state 147
    elif_stmnt                     shift and go to state 148
    else_stmnt                     shift and go to state 150
    simple_stmt                    shift and go to state 128
    empty                          shift and go to state 152
    small_stmt                     shift and go to state 5
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 126

    (54) suite -> NEWLINE . INDENT stmt

    INDENT          shift and go to state 153


state 127

    (36) compound_if -> IF test THEN itersuite . elif_stmnt else_stmnt
    (37) compound_if -> IF test THEN itersuite . if_stmnt else_stmnt
    (43) elif_stmnt -> . ELIF test THEN suite elif_stmnt
    (44) elif_stmnt -> . else_stmnt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (40) else_stmnt -> . ELSE THEN suite
    (41) else_stmnt -> . ELSE THEN if_stmnt
    (42) else_stmnt -> . empty
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (96) empty -> .

  ! shift/reduce conflict for ELIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    ELIF            shift and go to state 149
    IF              shift and go to state 12
    ELSE            shift and go to state 151
    NEWLINE         reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)

  ! ELIF            [ reduce using rule 96 (empty -> .) ]
  ! ELSE            [ reduce using rule 96 (empty -> .) ]
  ! IF              [ reduce using rule 96 (empty -> .) ]

    elif_stmnt                     shift and go to state 154
    else_stmnt                     shift and go to state 150
    if_stmnt                       shift and go to state 155
    compound_if                    shift and go to state 14
    empty                          shift and go to state 152

state 128

    (53) suite -> simple_stmt .

    NEWLINE         reduce using rule 53 (suite -> simple_stmt .)
    ELIF            reduce using rule 53 (suite -> simple_stmt .)
    ELSE            reduce using rule 53 (suite -> simple_stmt .)
    PRINT           reduce using rule 53 (suite -> simple_stmt .)
    CDEF            reduce using rule 53 (suite -> simple_stmt .)
    NOT             reduce using rule 53 (suite -> simple_stmt .)
    LPAREN          reduce using rule 53 (suite -> simple_stmt .)
    ID              reduce using rule 53 (suite -> simple_stmt .)
    NUMBER          reduce using rule 53 (suite -> simple_stmt .)
    STRING          reduce using rule 53 (suite -> simple_stmt .)
    BOOL_TRUE       reduce using rule 53 (suite -> simple_stmt .)
    BOOL_FALSE      reduce using rule 53 (suite -> simple_stmt .)
    NONE            reduce using rule 53 (suite -> simple_stmt .)
    IF              reduce using rule 53 (suite -> simple_stmt .)
    FOR             reduce using rule 53 (suite -> simple_stmt .)
    BREAK           reduce using rule 53 (suite -> simple_stmt .)
    $end            reduce using rule 53 (suite -> simple_stmt .)


state 129

    (13) input_stmt -> test ASSIGN INPUT LPAREN . STRING RPAREN

    STRING          shift and go to state 156


state 130

    (45) for_stmt -> FOR exprlist IN testlist . THEN stmt

    THEN            shift and go to state 157


state 131

    (46) for_stmt -> FOR exprlist IN RANGE . THEN stmt

    THEN            shift and go to state 158


state 132

    (50) testlist -> test . testlisthelper
    (51) testlisthelper -> . NEWLINE test exprlisthelper
    (52) testlisthelper -> . empty
    (96) empty -> .

    NEWLINE         shift and go to state 160
    THEN            reduce using rule 96 (empty -> .)

    testlisthelper                 shift and go to state 159
    empty                          shift and go to state 161

state 133

    (48) exprlisthelper -> NEWLINE expression . exprlisthelper
    (48) exprlisthelper -> . NEWLINE expression exprlisthelper
    (49) exprlisthelper -> . empty
    (96) empty -> .

    NEWLINE         shift and go to state 105
    IN              reduce using rule 96 (empty -> .)
    THEN            reduce using rule 96 (empty -> .)

    exprlisthelper                 shift and go to state 162
    empty                          shift and go to state 106

state 134

    (12) print_stmt -> PRINT LPAREN test RPAREN .

    NEWLINE         reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    IF              reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    FOR             reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    BREAK           reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    PRINT           reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    CDEF            reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    NOT             reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    LPAREN          reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    ID              reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    NUMBER          reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    STRING          reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    BOOL_TRUE       reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    BOOL_FALSE      reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    NONE            reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    $end            reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    ELIF            reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)
    ELSE            reduce using rule 12 (print_stmt -> PRINT LPAREN test RPAREN .)


state 135

    (85) factor -> LPAREN MINUS factor RPAREN .

    TIMES           reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    DIVIDE          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    MODULE          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    POWER           reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    PLUS            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    MINUS           reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    LESS_THAN       reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    MORE_THAN       reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    EQUALS          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    MORE_EQUAL      reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    LESS_EQUAL      reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    NOT_EQUAL       reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    IN              reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    NOT_IN          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    IS              reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    IS_NOT          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    AND             reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    OR              reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    ASSIGN          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    PLUS_ASSIGN     reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    MINUS_ASSIGN    reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    TIMES_ASSIGN    reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    DIVIDE_ASSIGN   reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    ASSIGN_MODULE   reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    THEN            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    NEWLINE         reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    IF              reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    FOR             reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    BREAK           reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    PRINT           reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    CDEF            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    NOT             reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    LPAREN          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    ID              reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    NUMBER          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    STRING          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    BOOL_TRUE       reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    BOOL_FALSE      reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    NONE            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    $end            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    ELIF            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    ELSE            reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)
    RPAREN          reduce using rule 85 (factor -> LPAREN MINUS factor RPAREN .)


state 136

    (18) vartypes -> INT test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 163
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 137

    (19) vartypes -> DOUBLE test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 164
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 138

    (20) vartypes -> SHORT test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 165
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 139

    (21) vartypes -> LONG test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 166
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 140

    (22) vartypes -> CHAR test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 167
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 141

    (23) vartypes -> FLOAT test ASSIGN . test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 168
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 142

    (57) or_comp -> OR and_test or_comp .

    ASSIGN          reduce using rule 57 (or_comp -> OR and_test or_comp .)
    PLUS_ASSIGN     reduce using rule 57 (or_comp -> OR and_test or_comp .)
    MINUS_ASSIGN    reduce using rule 57 (or_comp -> OR and_test or_comp .)
    TIMES_ASSIGN    reduce using rule 57 (or_comp -> OR and_test or_comp .)
    DIVIDE_ASSIGN   reduce using rule 57 (or_comp -> OR and_test or_comp .)
    ASSIGN_MODULE   reduce using rule 57 (or_comp -> OR and_test or_comp .)
    THEN            reduce using rule 57 (or_comp -> OR and_test or_comp .)
    NEWLINE         reduce using rule 57 (or_comp -> OR and_test or_comp .)
    IF              reduce using rule 57 (or_comp -> OR and_test or_comp .)
    FOR             reduce using rule 57 (or_comp -> OR and_test or_comp .)
    BREAK           reduce using rule 57 (or_comp -> OR and_test or_comp .)
    PRINT           reduce using rule 57 (or_comp -> OR and_test or_comp .)
    CDEF            reduce using rule 57 (or_comp -> OR and_test or_comp .)
    NOT             reduce using rule 57 (or_comp -> OR and_test or_comp .)
    LPAREN          reduce using rule 57 (or_comp -> OR and_test or_comp .)
    ID              reduce using rule 57 (or_comp -> OR and_test or_comp .)
    NUMBER          reduce using rule 57 (or_comp -> OR and_test or_comp .)
    STRING          reduce using rule 57 (or_comp -> OR and_test or_comp .)
    BOOL_TRUE       reduce using rule 57 (or_comp -> OR and_test or_comp .)
    BOOL_FALSE      reduce using rule 57 (or_comp -> OR and_test or_comp .)
    NONE            reduce using rule 57 (or_comp -> OR and_test or_comp .)
    $end            reduce using rule 57 (or_comp -> OR and_test or_comp .)
    ELIF            reduce using rule 57 (or_comp -> OR and_test or_comp .)
    ELSE            reduce using rule 57 (or_comp -> OR and_test or_comp .)
    RPAREN          reduce using rule 57 (or_comp -> OR and_test or_comp .)


state 143

    (60) and_comp -> AND not_test and_comp .

    OR              reduce using rule 60 (and_comp -> AND not_test and_comp .)
    ASSIGN          reduce using rule 60 (and_comp -> AND not_test and_comp .)
    PLUS_ASSIGN     reduce using rule 60 (and_comp -> AND not_test and_comp .)
    MINUS_ASSIGN    reduce using rule 60 (and_comp -> AND not_test and_comp .)
    TIMES_ASSIGN    reduce using rule 60 (and_comp -> AND not_test and_comp .)
    DIVIDE_ASSIGN   reduce using rule 60 (and_comp -> AND not_test and_comp .)
    ASSIGN_MODULE   reduce using rule 60 (and_comp -> AND not_test and_comp .)
    THEN            reduce using rule 60 (and_comp -> AND not_test and_comp .)
    NEWLINE         reduce using rule 60 (and_comp -> AND not_test and_comp .)
    IF              reduce using rule 60 (and_comp -> AND not_test and_comp .)
    FOR             reduce using rule 60 (and_comp -> AND not_test and_comp .)
    BREAK           reduce using rule 60 (and_comp -> AND not_test and_comp .)
    PRINT           reduce using rule 60 (and_comp -> AND not_test and_comp .)
    CDEF            reduce using rule 60 (and_comp -> AND not_test and_comp .)
    NOT             reduce using rule 60 (and_comp -> AND not_test and_comp .)
    LPAREN          reduce using rule 60 (and_comp -> AND not_test and_comp .)
    ID              reduce using rule 60 (and_comp -> AND not_test and_comp .)
    NUMBER          reduce using rule 60 (and_comp -> AND not_test and_comp .)
    STRING          reduce using rule 60 (and_comp -> AND not_test and_comp .)
    BOOL_TRUE       reduce using rule 60 (and_comp -> AND not_test and_comp .)
    BOOL_FALSE      reduce using rule 60 (and_comp -> AND not_test and_comp .)
    NONE            reduce using rule 60 (and_comp -> AND not_test and_comp .)
    $end            reduce using rule 60 (and_comp -> AND not_test and_comp .)
    ELIF            reduce using rule 60 (and_comp -> AND not_test and_comp .)
    ELSE            reduce using rule 60 (and_comp -> AND not_test and_comp .)
    RPAREN          reduce using rule 60 (and_comp -> AND not_test and_comp .)


state 144

    (65) comphelper -> comp_op expression comphelper .

    AND             reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    OR              reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    ASSIGN          reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    PLUS_ASSIGN     reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    MINUS_ASSIGN    reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    TIMES_ASSIGN    reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    DIVIDE_ASSIGN   reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    ASSIGN_MODULE   reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    THEN            reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    NEWLINE         reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    IF              reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    FOR             reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    BREAK           reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    PRINT           reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    CDEF            reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    NOT             reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    LPAREN          reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    ID              reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    NUMBER          reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    STRING          reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    BOOL_TRUE       reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    BOOL_FALSE      reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    NONE            reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    $end            reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    ELIF            reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    ELSE            reduce using rule 65 (comphelper -> comp_op expression comphelper .)
    RPAREN          reduce using rule 65 (comphelper -> comp_op expression comphelper .)


state 145

    (38) itersuite -> suite . itersuite
    (39) itersuite -> suite . elif_stmnt
    (38) itersuite -> . suite itersuite
    (39) itersuite -> . suite elif_stmnt
    (43) elif_stmnt -> . ELIF test THEN suite elif_stmnt
    (44) elif_stmnt -> . else_stmnt
    (53) suite -> . simple_stmt
    (54) suite -> . NEWLINE INDENT stmt
    (40) else_stmnt -> . ELSE THEN suite
    (41) else_stmnt -> . ELSE THEN if_stmnt
    (42) else_stmnt -> . empty
    (6) simple_stmt -> . small_stmt simplehelper
    (96) empty -> .
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ELIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CDEF resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL_TRUE resolved as shift
  ! shift/reduce conflict for BOOL_FALSE resolved as shift
  ! shift/reduce conflict for NONE resolved as shift
    ELIF            shift and go to state 149
    NEWLINE         shift and go to state 126
    ELSE            shift and go to state 151
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

  ! NEWLINE         [ reduce using rule 96 (empty -> .) ]
  ! ELIF            [ reduce using rule 96 (empty -> .) ]
  ! ELSE            [ reduce using rule 96 (empty -> .) ]
  ! PRINT           [ reduce using rule 96 (empty -> .) ]
  ! CDEF            [ reduce using rule 96 (empty -> .) ]
  ! NOT             [ reduce using rule 96 (empty -> .) ]
  ! LPAREN          [ reduce using rule 96 (empty -> .) ]
  ! ID              [ reduce using rule 96 (empty -> .) ]
  ! NUMBER          [ reduce using rule 96 (empty -> .) ]
  ! STRING          [ reduce using rule 96 (empty -> .) ]
  ! BOOL_TRUE       [ reduce using rule 96 (empty -> .) ]
  ! BOOL_FALSE      [ reduce using rule 96 (empty -> .) ]
  ! NONE            [ reduce using rule 96 (empty -> .) ]

    suite                          shift and go to state 145
    itersuite                      shift and go to state 147
    elif_stmnt                     shift and go to state 148
    test                           shift and go to state 13
    else_stmnt                     shift and go to state 150
    simple_stmt                    shift and go to state 128
    empty                          shift and go to state 152
    small_stmt                     shift and go to state 5
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 146

    (34) if_stmnt -> IF test THEN suite NEWLINE .
    (54) suite -> NEWLINE . INDENT stmt

    IF              reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    FOR             reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    BREAK           reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    PRINT           reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    CDEF            reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    NOT             reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    LPAREN          reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    ID              reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    NUMBER          reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    STRING          reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    BOOL_TRUE       reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    BOOL_FALSE      reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    NONE            reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    $end            reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    NEWLINE         reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    ELIF            reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    ELSE            reduce using rule 34 (if_stmnt -> IF test THEN suite NEWLINE .)
    INDENT          shift and go to state 153


state 147

    (38) itersuite -> suite itersuite .

    NEWLINE         reduce using rule 38 (itersuite -> suite itersuite .)
    ELIF            reduce using rule 38 (itersuite -> suite itersuite .)
    ELSE            reduce using rule 38 (itersuite -> suite itersuite .)
    PRINT           reduce using rule 38 (itersuite -> suite itersuite .)
    CDEF            reduce using rule 38 (itersuite -> suite itersuite .)
    NOT             reduce using rule 38 (itersuite -> suite itersuite .)
    LPAREN          reduce using rule 38 (itersuite -> suite itersuite .)
    ID              reduce using rule 38 (itersuite -> suite itersuite .)
    NUMBER          reduce using rule 38 (itersuite -> suite itersuite .)
    STRING          reduce using rule 38 (itersuite -> suite itersuite .)
    BOOL_TRUE       reduce using rule 38 (itersuite -> suite itersuite .)
    BOOL_FALSE      reduce using rule 38 (itersuite -> suite itersuite .)
    NONE            reduce using rule 38 (itersuite -> suite itersuite .)
    IF              reduce using rule 38 (itersuite -> suite itersuite .)
    FOR             reduce using rule 38 (itersuite -> suite itersuite .)
    BREAK           reduce using rule 38 (itersuite -> suite itersuite .)
    $end            reduce using rule 38 (itersuite -> suite itersuite .)


state 148

    (39) itersuite -> suite elif_stmnt .

    NEWLINE         reduce using rule 39 (itersuite -> suite elif_stmnt .)
    ELIF            reduce using rule 39 (itersuite -> suite elif_stmnt .)
    ELSE            reduce using rule 39 (itersuite -> suite elif_stmnt .)
    PRINT           reduce using rule 39 (itersuite -> suite elif_stmnt .)
    CDEF            reduce using rule 39 (itersuite -> suite elif_stmnt .)
    NOT             reduce using rule 39 (itersuite -> suite elif_stmnt .)
    LPAREN          reduce using rule 39 (itersuite -> suite elif_stmnt .)
    ID              reduce using rule 39 (itersuite -> suite elif_stmnt .)
    NUMBER          reduce using rule 39 (itersuite -> suite elif_stmnt .)
    STRING          reduce using rule 39 (itersuite -> suite elif_stmnt .)
    BOOL_TRUE       reduce using rule 39 (itersuite -> suite elif_stmnt .)
    BOOL_FALSE      reduce using rule 39 (itersuite -> suite elif_stmnt .)
    NONE            reduce using rule 39 (itersuite -> suite elif_stmnt .)
    IF              reduce using rule 39 (itersuite -> suite elif_stmnt .)
    FOR             reduce using rule 39 (itersuite -> suite elif_stmnt .)
    BREAK           reduce using rule 39 (itersuite -> suite elif_stmnt .)
    $end            reduce using rule 39 (itersuite -> suite elif_stmnt .)


state 149

    (43) elif_stmnt -> ELIF . test THEN suite elif_stmnt
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 169
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 150

    (44) elif_stmnt -> else_stmnt .

    NEWLINE         reduce using rule 44 (elif_stmnt -> else_stmnt .)
    ELIF            reduce using rule 44 (elif_stmnt -> else_stmnt .)
    ELSE            reduce using rule 44 (elif_stmnt -> else_stmnt .)
    PRINT           reduce using rule 44 (elif_stmnt -> else_stmnt .)
    CDEF            reduce using rule 44 (elif_stmnt -> else_stmnt .)
    NOT             reduce using rule 44 (elif_stmnt -> else_stmnt .)
    LPAREN          reduce using rule 44 (elif_stmnt -> else_stmnt .)
    ID              reduce using rule 44 (elif_stmnt -> else_stmnt .)
    NUMBER          reduce using rule 44 (elif_stmnt -> else_stmnt .)
    STRING          reduce using rule 44 (elif_stmnt -> else_stmnt .)
    BOOL_TRUE       reduce using rule 44 (elif_stmnt -> else_stmnt .)
    BOOL_FALSE      reduce using rule 44 (elif_stmnt -> else_stmnt .)
    NONE            reduce using rule 44 (elif_stmnt -> else_stmnt .)
    IF              reduce using rule 44 (elif_stmnt -> else_stmnt .)
    FOR             reduce using rule 44 (elif_stmnt -> else_stmnt .)
    BREAK           reduce using rule 44 (elif_stmnt -> else_stmnt .)
    $end            reduce using rule 44 (elif_stmnt -> else_stmnt .)


state 151

    (40) else_stmnt -> ELSE . THEN suite
    (41) else_stmnt -> ELSE . THEN if_stmnt

    THEN            shift and go to state 170


state 152

    (42) else_stmnt -> empty .

    NEWLINE         reduce using rule 42 (else_stmnt -> empty .)
    ELIF            reduce using rule 42 (else_stmnt -> empty .)
    ELSE            reduce using rule 42 (else_stmnt -> empty .)
    PRINT           reduce using rule 42 (else_stmnt -> empty .)
    CDEF            reduce using rule 42 (else_stmnt -> empty .)
    NOT             reduce using rule 42 (else_stmnt -> empty .)
    LPAREN          reduce using rule 42 (else_stmnt -> empty .)
    ID              reduce using rule 42 (else_stmnt -> empty .)
    NUMBER          reduce using rule 42 (else_stmnt -> empty .)
    STRING          reduce using rule 42 (else_stmnt -> empty .)
    BOOL_TRUE       reduce using rule 42 (else_stmnt -> empty .)
    BOOL_FALSE      reduce using rule 42 (else_stmnt -> empty .)
    NONE            reduce using rule 42 (else_stmnt -> empty .)
    IF              reduce using rule 42 (else_stmnt -> empty .)
    FOR             reduce using rule 42 (else_stmnt -> empty .)
    BREAK           reduce using rule 42 (else_stmnt -> empty .)
    $end            reduce using rule 42 (else_stmnt -> empty .)


state 153

    (54) suite -> NEWLINE INDENT . stmt
    (4) stmt -> . simple_stmt
    (5) stmt -> . compound_stmt
    (6) simple_stmt -> . small_stmt simplehelper
    (30) compound_stmt -> . if_stmnt
    (31) compound_stmt -> . for_stmt
    (32) compound_stmt -> . break_stmt
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (45) for_stmt -> . FOR exprlist IN testlist THEN stmt
    (46) for_stmt -> . FOR exprlist IN RANGE THEN stmt
    (33) break_stmt -> . BREAK
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    IF              shift and go to state 12
    FOR             shift and go to state 15
    BREAK           shift and go to state 16
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    stmt                           shift and go to state 171
    simple_stmt                    shift and go to state 3
    compound_stmt                  shift and go to state 4
    small_stmt                     shift and go to state 5
    if_stmnt                       shift and go to state 6
    for_stmt                       shift and go to state 7
    break_stmt                     shift and go to state 8
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    test                           shift and go to state 13
    compound_if                    shift and go to state 14
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 154

    (36) compound_if -> IF test THEN itersuite elif_stmnt . else_stmnt
    (40) else_stmnt -> . ELSE THEN suite
    (41) else_stmnt -> . ELSE THEN if_stmnt
    (42) else_stmnt -> . empty
    (96) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 151
    NEWLINE         reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)

  ! ELSE            [ reduce using rule 96 (empty -> .) ]

    else_stmnt                     shift and go to state 172
    empty                          shift and go to state 152

state 155

    (37) compound_if -> IF test THEN itersuite if_stmnt . else_stmnt
    (40) else_stmnt -> . ELSE THEN suite
    (41) else_stmnt -> . ELSE THEN if_stmnt
    (42) else_stmnt -> . empty
    (96) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 151
    NEWLINE         reduce using rule 96 (empty -> .)
    ELIF            reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)

  ! ELSE            [ reduce using rule 96 (empty -> .) ]

    else_stmnt                     shift and go to state 173
    empty                          shift and go to state 152

state 156

    (13) input_stmt -> test ASSIGN INPUT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 174


state 157

    (45) for_stmt -> FOR exprlist IN testlist THEN . stmt
    (4) stmt -> . simple_stmt
    (5) stmt -> . compound_stmt
    (6) simple_stmt -> . small_stmt simplehelper
    (30) compound_stmt -> . if_stmnt
    (31) compound_stmt -> . for_stmt
    (32) compound_stmt -> . break_stmt
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (45) for_stmt -> . FOR exprlist IN testlist THEN stmt
    (46) for_stmt -> . FOR exprlist IN RANGE THEN stmt
    (33) break_stmt -> . BREAK
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    IF              shift and go to state 12
    FOR             shift and go to state 15
    BREAK           shift and go to state 16
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    stmt                           shift and go to state 175
    simple_stmt                    shift and go to state 3
    compound_stmt                  shift and go to state 4
    small_stmt                     shift and go to state 5
    if_stmnt                       shift and go to state 6
    for_stmt                       shift and go to state 7
    break_stmt                     shift and go to state 8
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    test                           shift and go to state 13
    compound_if                    shift and go to state 14
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 158

    (46) for_stmt -> FOR exprlist IN RANGE THEN . stmt
    (4) stmt -> . simple_stmt
    (5) stmt -> . compound_stmt
    (6) simple_stmt -> . small_stmt simplehelper
    (30) compound_stmt -> . if_stmnt
    (31) compound_stmt -> . for_stmt
    (32) compound_stmt -> . break_stmt
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (45) for_stmt -> . FOR exprlist IN testlist THEN stmt
    (46) for_stmt -> . FOR exprlist IN RANGE THEN stmt
    (33) break_stmt -> . BREAK
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    IF              shift and go to state 12
    FOR             shift and go to state 15
    BREAK           shift and go to state 16
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    stmt                           shift and go to state 176
    simple_stmt                    shift and go to state 3
    compound_stmt                  shift and go to state 4
    small_stmt                     shift and go to state 5
    if_stmnt                       shift and go to state 6
    for_stmt                       shift and go to state 7
    break_stmt                     shift and go to state 8
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    test                           shift and go to state 13
    compound_if                    shift and go to state 14
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 159

    (50) testlist -> test testlisthelper .

    THEN            reduce using rule 50 (testlist -> test testlisthelper .)


state 160

    (51) testlisthelper -> NEWLINE . test exprlisthelper
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 177
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 161

    (52) testlisthelper -> empty .

    THEN            reduce using rule 52 (testlisthelper -> empty .)


state 162

    (48) exprlisthelper -> NEWLINE expression exprlisthelper .

    IN              reduce using rule 48 (exprlisthelper -> NEWLINE expression exprlisthelper .)
    THEN            reduce using rule 48 (exprlisthelper -> NEWLINE expression exprlisthelper .)


state 163

    (18) vartypes -> INT test ASSIGN test .

    NEWLINE         reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    IF              reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    FOR             reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    BREAK           reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    PRINT           reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    CDEF            reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    NOT             reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    LPAREN          reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    ID              reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    NUMBER          reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    STRING          reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    BOOL_TRUE       reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    BOOL_FALSE      reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    NONE            reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    $end            reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    ELIF            reduce using rule 18 (vartypes -> INT test ASSIGN test .)
    ELSE            reduce using rule 18 (vartypes -> INT test ASSIGN test .)


state 164

    (19) vartypes -> DOUBLE test ASSIGN test .

    NEWLINE         reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    IF              reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    FOR             reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    BREAK           reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    PRINT           reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    CDEF            reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    NOT             reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    LPAREN          reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    ID              reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    NUMBER          reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    STRING          reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    BOOL_TRUE       reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    BOOL_FALSE      reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    NONE            reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    $end            reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    ELIF            reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)
    ELSE            reduce using rule 19 (vartypes -> DOUBLE test ASSIGN test .)


state 165

    (20) vartypes -> SHORT test ASSIGN test .

    NEWLINE         reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    IF              reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    FOR             reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    BREAK           reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    PRINT           reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    CDEF            reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    NOT             reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    LPAREN          reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    ID              reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    NUMBER          reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    STRING          reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    BOOL_TRUE       reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    BOOL_FALSE      reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    NONE            reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    $end            reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    ELIF            reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)
    ELSE            reduce using rule 20 (vartypes -> SHORT test ASSIGN test .)


state 166

    (21) vartypes -> LONG test ASSIGN test .

    NEWLINE         reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    IF              reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    FOR             reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    BREAK           reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    PRINT           reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    CDEF            reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    NOT             reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    LPAREN          reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    ID              reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    NUMBER          reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    STRING          reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    BOOL_TRUE       reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    BOOL_FALSE      reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    NONE            reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    $end            reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    ELIF            reduce using rule 21 (vartypes -> LONG test ASSIGN test .)
    ELSE            reduce using rule 21 (vartypes -> LONG test ASSIGN test .)


state 167

    (22) vartypes -> CHAR test ASSIGN test .

    NEWLINE         reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    IF              reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    FOR             reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    BREAK           reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    PRINT           reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    CDEF            reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    NOT             reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    LPAREN          reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    ID              reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    NUMBER          reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    STRING          reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    BOOL_TRUE       reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    BOOL_FALSE      reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    NONE            reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    $end            reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    ELIF            reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)
    ELSE            reduce using rule 22 (vartypes -> CHAR test ASSIGN test .)


state 168

    (23) vartypes -> FLOAT test ASSIGN test .

    NEWLINE         reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    IF              reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    FOR             reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    BREAK           reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    PRINT           reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    CDEF            reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    NOT             reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    LPAREN          reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    ID              reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    NUMBER          reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    STRING          reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    BOOL_TRUE       reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    BOOL_FALSE      reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    NONE            reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    $end            reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    ELIF            reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)
    ELSE            reduce using rule 23 (vartypes -> FLOAT test ASSIGN test .)


state 169

    (43) elif_stmnt -> ELIF test . THEN suite elif_stmnt

    THEN            shift and go to state 178


state 170

    (40) else_stmnt -> ELSE THEN . suite
    (41) else_stmnt -> ELSE THEN . if_stmnt
    (53) suite -> . simple_stmt
    (54) suite -> . NEWLINE INDENT stmt
    (34) if_stmnt -> . IF test THEN suite NEWLINE
    (35) if_stmnt -> . compound_if
    (6) simple_stmt -> . small_stmt simplehelper
    (36) compound_if -> . IF test THEN itersuite elif_stmnt else_stmnt
    (37) compound_if -> . IF test THEN itersuite if_stmnt else_stmnt
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NEWLINE         shift and go to state 126
    IF              shift and go to state 12
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    suite                          shift and go to state 179
    if_stmnt                       shift and go to state 180
    simple_stmt                    shift and go to state 128
    test                           shift and go to state 13
    compound_if                    shift and go to state 14
    small_stmt                     shift and go to state 5
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 171

    (54) suite -> NEWLINE INDENT stmt .

    NEWLINE         reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    ELIF            reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    ELSE            reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    PRINT           reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    CDEF            reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    NOT             reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    LPAREN          reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    ID              reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    NUMBER          reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    STRING          reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    BOOL_TRUE       reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    BOOL_FALSE      reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    NONE            reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    IF              reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    FOR             reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    BREAK           reduce using rule 54 (suite -> NEWLINE INDENT stmt .)
    $end            reduce using rule 54 (suite -> NEWLINE INDENT stmt .)


state 172

    (36) compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .

    IF              reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    FOR             reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    BREAK           reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    PRINT           reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    CDEF            reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    NOT             reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    LPAREN          reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    ID              reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    NUMBER          reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    STRING          reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    BOOL_TRUE       reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    BOOL_FALSE      reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    NONE            reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    $end            reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    NEWLINE         reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    ELIF            reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)
    ELSE            reduce using rule 36 (compound_if -> IF test THEN itersuite elif_stmnt else_stmnt .)


state 173

    (37) compound_if -> IF test THEN itersuite if_stmnt else_stmnt .

    IF              reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    FOR             reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    BREAK           reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    PRINT           reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    CDEF            reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    NOT             reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    LPAREN          reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    ID              reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    NUMBER          reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    STRING          reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    BOOL_TRUE       reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    BOOL_FALSE      reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    NONE            reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    $end            reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    NEWLINE         reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    ELIF            reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)
    ELSE            reduce using rule 37 (compound_if -> IF test THEN itersuite if_stmnt else_stmnt .)


state 174

    (13) input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .

    NEWLINE         reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    IF              reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    FOR             reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    BREAK           reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    PRINT           reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    CDEF            reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    NOT             reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    LPAREN          reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    ID              reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    NUMBER          reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    STRING          reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    BOOL_TRUE       reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    BOOL_FALSE      reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    NONE            reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    $end            reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    ELIF            reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)
    ELSE            reduce using rule 13 (input_stmt -> test ASSIGN INPUT LPAREN STRING RPAREN .)


state 175

    (45) for_stmt -> FOR exprlist IN testlist THEN stmt .

    IF              reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    FOR             reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    BREAK           reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    PRINT           reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    CDEF            reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    NOT             reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    LPAREN          reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    ID              reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    NUMBER          reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    STRING          reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    BOOL_TRUE       reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    BOOL_FALSE      reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    NONE            reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    $end            reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    NEWLINE         reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    ELIF            reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)
    ELSE            reduce using rule 45 (for_stmt -> FOR exprlist IN testlist THEN stmt .)


state 176

    (46) for_stmt -> FOR exprlist IN RANGE THEN stmt .

    IF              reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    FOR             reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    BREAK           reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    PRINT           reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    CDEF            reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    NOT             reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    LPAREN          reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    ID              reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    NUMBER          reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    STRING          reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    BOOL_TRUE       reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    BOOL_FALSE      reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    NONE            reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    $end            reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    NEWLINE         reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    ELIF            reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)
    ELSE            reduce using rule 46 (for_stmt -> FOR exprlist IN RANGE THEN stmt .)


state 177

    (51) testlisthelper -> NEWLINE test . exprlisthelper
    (48) exprlisthelper -> . NEWLINE expression exprlisthelper
    (49) exprlisthelper -> . empty
    (96) empty -> .

    NEWLINE         shift and go to state 105
    THEN            reduce using rule 96 (empty -> .)

    exprlisthelper                 shift and go to state 181
    empty                          shift and go to state 106

state 178

    (43) elif_stmnt -> ELIF test THEN . suite elif_stmnt
    (53) suite -> . simple_stmt
    (54) suite -> . NEWLINE INDENT stmt
    (6) simple_stmt -> . small_stmt simplehelper
    (9) small_stmt -> . expr_stmt
    (10) small_stmt -> . print_stmt
    (11) small_stmt -> . input_stmt
    (14) expr_stmt -> . typotest
    (15) expr_stmt -> . augassign
    (16) expr_stmt -> . annassign
    (12) print_stmt -> . PRINT LPAREN test RPAREN
    (13) input_stmt -> . test ASSIGN INPUT LPAREN STRING RPAREN
    (17) typotest -> . CDEF vartypes
    (25) augassign -> . test PLUS_ASSIGN test
    (26) augassign -> . test MINUS_ASSIGN test
    (27) augassign -> . test TIMES_ASSIGN test
    (28) augassign -> . test DIVIDE_ASSIGN test
    (29) augassign -> . test ASSIGN_MODULE test
    (24) annassign -> . test ASSIGN test
    (55) test -> . or_test
    (56) or_test -> . and_test or_comp
    (59) and_test -> . not_test and_comp
    (62) not_test -> . NOT not_test
    (63) not_test -> . comparison
    (64) comparison -> . expression comphelper
    (77) expression -> . arith_expr
    (78) arith_expr -> . term PLUS arith_expr
    (79) arith_expr -> . term MINUS arith_expr
    (80) arith_expr -> . term empty
    (81) term -> . factor TIMES term
    (82) term -> . factor DIVIDE term
    (83) term -> . factor MODULE term
    (84) term -> . factor empty
    (85) factor -> . LPAREN MINUS factor RPAREN
    (86) factor -> . power
    (87) power -> . factor POWER factor
    (88) power -> . atom_expr empty
    (89) atom_expr -> . atom
    (90) atom -> . ID
    (91) atom -> . NUMBER
    (92) atom -> . STRING
    (93) atom -> . BOOL_TRUE
    (94) atom -> . BOOL_FALSE
    (95) atom -> . NONE

    NEWLINE         shift and go to state 126
    PRINT           shift and go to state 20
    CDEF            shift and go to state 23
    NOT             shift and go to state 27
    LPAREN          shift and go to state 21
    ID              shift and go to state 36
    NUMBER          shift and go to state 37
    STRING          shift and go to state 22
    BOOL_TRUE       shift and go to state 38
    BOOL_FALSE      shift and go to state 39
    NONE            shift and go to state 40

    test                           shift and go to state 13
    suite                          shift and go to state 182
    simple_stmt                    shift and go to state 128
    small_stmt                     shift and go to state 5
    expr_stmt                      shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    typotest                       shift and go to state 17
    augassign                      shift and go to state 18
    annassign                      shift and go to state 19
    or_test                        shift and go to state 24
    and_test                       shift and go to state 25
    not_test                       shift and go to state 26
    comparison                     shift and go to state 28
    expression                     shift and go to state 29
    arith_expr                     shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 32
    power                          shift and go to state 33
    atom_expr                      shift and go to state 34
    atom                           shift and go to state 35

state 179

    (40) else_stmnt -> ELSE THEN suite .

    NEWLINE         reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    ELIF            reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    ELSE            reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    PRINT           reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    CDEF            reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    NOT             reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    LPAREN          reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    ID              reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    NUMBER          reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    STRING          reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    BOOL_TRUE       reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    BOOL_FALSE      reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    NONE            reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    IF              reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    FOR             reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    BREAK           reduce using rule 40 (else_stmnt -> ELSE THEN suite .)
    $end            reduce using rule 40 (else_stmnt -> ELSE THEN suite .)


state 180

    (41) else_stmnt -> ELSE THEN if_stmnt .

    NEWLINE         reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    ELIF            reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    ELSE            reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    PRINT           reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    CDEF            reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    NOT             reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    LPAREN          reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    ID              reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    NUMBER          reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    STRING          reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    BOOL_TRUE       reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    BOOL_FALSE      reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    NONE            reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    IF              reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    FOR             reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    BREAK           reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)
    $end            reduce using rule 41 (else_stmnt -> ELSE THEN if_stmnt .)


state 181

    (51) testlisthelper -> NEWLINE test exprlisthelper .

    THEN            reduce using rule 51 (testlisthelper -> NEWLINE test exprlisthelper .)


state 182

    (43) elif_stmnt -> ELIF test THEN suite . elif_stmnt
    (43) elif_stmnt -> . ELIF test THEN suite elif_stmnt
    (44) elif_stmnt -> . else_stmnt
    (40) else_stmnt -> . ELSE THEN suite
    (41) else_stmnt -> . ELSE THEN if_stmnt
    (42) else_stmnt -> . empty
    (96) empty -> .

  ! shift/reduce conflict for ELIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    ELIF            shift and go to state 149
    ELSE            shift and go to state 151
    NEWLINE         reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    CDEF            reduce using rule 96 (empty -> .)
    NOT             reduce using rule 96 (empty -> .)
    LPAREN          reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    NUMBER          reduce using rule 96 (empty -> .)
    STRING          reduce using rule 96 (empty -> .)
    BOOL_TRUE       reduce using rule 96 (empty -> .)
    BOOL_FALSE      reduce using rule 96 (empty -> .)
    NONE            reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    $end            reduce using rule 96 (empty -> .)

  ! ELIF            [ reduce using rule 96 (empty -> .) ]
  ! ELSE            [ reduce using rule 96 (empty -> .) ]

    elif_stmnt                     shift and go to state 183
    else_stmnt                     shift and go to state 150
    empty                          shift and go to state 152

state 183

    (43) elif_stmnt -> ELIF test THEN suite elif_stmnt .

    NEWLINE         reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    ELIF            reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    ELSE            reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    PRINT           reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    CDEF            reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    NOT             reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    LPAREN          reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    ID              reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    NUMBER          reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    STRING          reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    BOOL_TRUE       reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    BOOL_FALSE      reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    NONE            reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    IF              reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    FOR             reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    BREAK           reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)
    $end            reduce using rule 43 (elif_stmnt -> ELIF test THEN suite elif_stmnt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 94 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 125 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 125 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 125 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 125 resolved as shift
WARNING: shift/reduce conflict for CDEF in state 125 resolved as shift
WARNING: shift/reduce conflict for NOT in state 125 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 125 resolved as shift
WARNING: shift/reduce conflict for ID in state 125 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 125 resolved as shift
WARNING: shift/reduce conflict for STRING in state 125 resolved as shift
WARNING: shift/reduce conflict for BOOL_TRUE in state 125 resolved as shift
WARNING: shift/reduce conflict for BOOL_FALSE in state 125 resolved as shift
WARNING: shift/reduce conflict for NONE in state 125 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 127 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 127 resolved as shift
WARNING: shift/reduce conflict for IF in state 127 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 145 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 145 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 145 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 145 resolved as shift
WARNING: shift/reduce conflict for CDEF in state 145 resolved as shift
WARNING: shift/reduce conflict for NOT in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for ID in state 145 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 145 resolved as shift
WARNING: shift/reduce conflict for STRING in state 145 resolved as shift
WARNING: shift/reduce conflict for BOOL_TRUE in state 145 resolved as shift
WARNING: shift/reduce conflict for BOOL_FALSE in state 145 resolved as shift
WARNING: shift/reduce conflict for NONE in state 145 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 154 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 155 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 182 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 182 resolved as shift
